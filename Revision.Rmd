---
title: "Revision"
author: "Naitong Chen, Shirley Cui, Shannon Edie"
date: "3/27/2021"
output: html_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r read.data.in, results='hide', warning=FALSE}
chardonnay2019 = read.csv("TanjaVoegel_Chardonnay_2019_data.csv")
chardonnay2020 = read.csv("TanjaVoegel_Chardonnay_2020_data.csv")
merlot2019 = read.csv("TanjaVoegel_Merlot_2019_data.csv")
merlot2020 = read.csv("TanjaVoegel_Merlot_2020_data.csv")
addition2021 = read.csv("data addition March 8 2021.csv")

# removing extra columns
merlot2020 = merlot2020[-(61:65),]
merlot2020 = merlot2020[,-(19:20)]
merlot2019 = merlot2019[-(61:65),]
merlot2019 = merlot2019[,-18]

# Make sure the merlot column names are consistent
colnames(merlot2020)[colnames(merlot2020)=="spad"] = "SPAD"

# filling in zero for yield related entries
merlot2020$yield[is.na(merlot2020$yield)] = 0
merlot2020$cluster.weight[is.na(merlot2020$cluster.weight)] = 0
merlot2020$berries.cluster[is.na(merlot2020$berries.cluster)] = 0
merlot2020$berry.weight[is.na(merlot2020$berry.weight)] = 0
merlot2020$cluster.number[is.na(merlot2020$cluster.number)] = 0

# encode row, treatment, block, and subsample as factor
chardonnay2019$row = as.factor(chardonnay2019$row)
chardonnay2019$treatment = as.factor(chardonnay2019$treatment)
chardonnay2019$block = as.factor(chardonnay2019$block)
chardonnay2019$subsample = as.factor(chardonnay2019$subsample)

chardonnay2020$row = as.factor(chardonnay2020$row)
chardonnay2020$treatment = as.factor(chardonnay2020$treatment)
chardonnay2020$block = as.factor(chardonnay2020$block)
chardonnay2020$subsample = as.factor(chardonnay2020$subsample)

merlot2019$row = as.factor(merlot2019$row)
merlot2019$treatment = as.factor(merlot2019$treatment)
merlot2019$block = as.factor(merlot2019$block)
merlot2019$subsample = as.factor(merlot2019$subsample)


merlot2020$row = as.factor(merlot2020$row)
merlot2020$treatment = as.factor(merlot2020$treatment)
merlot2020$block = as.factor(merlot2020$block)
merlot2020$subsample = as.factor(merlot2020$subsample)

library(plyr)
# Add in the additional data
names(merlot2020)[1] <- "Key"
merlot2020 <- join(merlot2020, addition2021)

# detach plyr as it creates conflict with tidyverse
detach(package:plyr)
# remove unused dataset
remove(addition2021)
```

```{r packages, echo=F, results='hide'}
library(tidyverse)
library(ggpubr) 
library(corrplot)
library(icenReg) # for survival analysis
library(knitr)
library(lawstat) # for the levene test
library(mice)
library(miceadds)
library(MKinfer)
library(rstatix) # for the repeated-measures ANOVA
library(ARTool) # for aligned rank transform
library(maditr) # for dcast
library(pwr2)
library(kableExtra)
library(magick)
```

```{r chardonnay2019.normality.check, results='hide'}

# chardonnay 2019

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
resp.char19 <- colnames(chardonnay2019)[-c(1:5)]
norm.tests.char19 <- array(NA, c(10, length(resp.char19)))
colnames(norm.tests.char19) <- resp.char19
rownames(norm.tests.char19) <- unique(paste(chardonnay2019$block, chardonnay2019$treatment))[order(unique(paste(chardonnay2019$block, chardonnay2019$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the chardonnay 2019 dataset
for (i in 1:length(resp.char19)) {
  shapiro.results <- with(chardonnay2019, {lapply(split(eval(parse(text=resp.char19[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:10) {norm.tests.char19[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.char19<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.char19)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.char19)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(2,2), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(chardonnay2019[which(paste(chardonnay2019$block, chardonnay2019$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(chardonnay2019[which(paste(chardonnay2019$block, chardonnay2019$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.char19

```

```{r chardonnay2019.variance.check}
homosc.table.char19 <- array(data=NA, dim=c(length(resp.char19), 2))
dimnames(homosc.table.char19)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.char19)[[1]] <- resp.char19

for (i in 1:length(resp.char19)) {
  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- with(chardonnay2019, 
                               bartlett.test(eval(parse(text=resp.char19[i])) ~ paste(treatment, block)))$p.value
  lev.p  <- with(chardonnay2019, 
                        levene.test(eval(parse(text=resp.char19[i])), paste(treatment, block)))$p.value
  homosc.table.char19[i,1] <- bart.p
  homosc.table.char19[i,2] <- lev.p
}

for (i in 1:length(resp.char19)) {
  boxplot(chardonnay2019[[resp.char19[i]]] ~ chardonnay2019$treatment + chardonnay2019$block,
        xlab="Treatment + Block")
}

homosc.table.char19
```

```{r chardonnay2019.normality.check.transformed}

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
resp.char19 <- colnames(chardonnay2019)[-c(1:5)]
norm.tests.char19 <- array(NA, c(10, length(resp.char19)))
colnames(norm.tests.char19) <- resp.char19
rownames(norm.tests.char19) <- unique(paste(chardonnay2019$block, chardonnay2019$treatment))[order(unique(paste(chardonnay2019$block, chardonnay2019$treatment)))]

chardonnay2019_logged = chardonnay2019
chardonnay2019_logged[,-c(1:5)] = log(chardonnay2019_logged[,-c(1:5)])

# Run the shapiro wilkes test on each of the outcome variables in the chardonnay 2019 dataset
for (i in 1:length(resp.char19)) {
  shapiro.results <- with(chardonnay2019_logged, {lapply(split(eval(parse(text=resp.char19[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:10) {norm.tests.char19[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.char19<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.char19)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.char19)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(2,2), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(chardonnay2019_logged[which(paste(chardonnay2019_logged$block, chardonnay2019_logged$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(chardonnay2019_logged[which(paste(chardonnay2019_logged$block, chardonnay2019_logged$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.char19

```

```{r chardonnay2019.variance.check.transformed}
homosc.table.char19 <- array(data=NA, dim=c(length(resp.char19), 2))
dimnames(homosc.table.char19)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.char19)[[1]] <- resp.char19

for (i in 1:length(resp.char19)) {
  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- with(chardonnay2019_logged, 
                               bartlett.test(eval(parse(text=resp.char19[i])) ~ paste(treatment, block)))$p.value
  lev.p  <- with(chardonnay2019_logged, 
                        levene.test(eval(parse(text=resp.char19[i])), paste(treatment, block)))$p.value
  homosc.table.char19[i,1] <- bart.p
  homosc.table.char19[i,2] <- lev.p
}

for (i in 1:length(resp.char19)) {
  boxplot(chardonnay2019_logged[[resp.char19[i]]] ~ chardonnay2019_logged$treatment + chardonnay2019_logged$block,
        xlab="Treatment + Block")
}

homosc.table.char19
```

```{r chardonnay2020.normality.check}
resp.char20 <- colnames(chardonnay2020)[-c(1:5)]
# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.char20 <- array(NA, c(10, length(resp.char20)))
colnames(norm.tests.char20) <- resp.char20
rownames(norm.tests.char20) <- unique(paste(chardonnay2020$block, chardonnay2020$treatment))[order(unique(paste(chardonnay2020$block, chardonnay2020$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the chardonnay 2019 dataset
for (i in 1:length(resp.char20)) {
  shapiro.results <- with(chardonnay2020, {lapply(split(eval(parse(text=resp.char20[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:10) {norm.tests.char20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.char20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.char20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.char20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(2,2), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(chardonnay2020[which(paste(chardonnay2020$block, chardonnay2020$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(chardonnay2020[which(paste(chardonnay2020$block, chardonnay2020$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.char20
```

```{r chardonnay2020.variance.check}
homosc.table.char20 <- array(data=NA, dim=c(length(resp.char20), 2))
dimnames(homosc.table.char20)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.char20)[[1]] <- resp.char19

for (i in 1:length(resp.char20)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- with(chardonnay2020, 
                               bartlett.test(eval(parse(text=resp.char20[i])) ~ paste(treatment, block)))$p.value
  lev.p  <- with(chardonnay2020, 
                        levene.test(eval(parse(text=resp.char20[i])), paste(treatment, block)))$p.value
  homosc.table.char20[i,1] <- bart.p
  homosc.table.char20[i,2] <- lev.p
}

for (i in 1:length(resp.char20)) {
  boxplot(chardonnay2020[[resp.char20[i]]] ~ chardonnay2020$treatment + chardonnay2020$block,
        xlab="Treatment + Block")
}

homosc.table.char20
```

```{r chardonnay2020.normality.check.transformed}

chardonnay2020_logged = chardonnay2020
chardonnay2020_logged[,-c(1:5)] = log(chardonnay2020_logged[,-c(1:5)])

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.char20 <- array(NA, c(10, length(resp.char20)))
colnames(norm.tests.char20) <- resp.char20
rownames(norm.tests.char20) <- unique(paste(chardonnay2020$block, chardonnay2020$treatment))[order(unique(paste(chardonnay2020$block, chardonnay2020$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the chardonnay 2019 dataset
for (i in 1:length(resp.char20)) {
  shapiro.results <- with(chardonnay2020_logged, {lapply(split(eval(parse(text=resp.char20[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:10) {norm.tests.char20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.char20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.char20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.char20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(2,2), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(chardonnay2020_logged[which(paste(chardonnay2020_logged$block, chardonnay2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(chardonnay2020_logged[which(paste(chardonnay2020_logged$block, chardonnay2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.char20
```

```{r chardonnay2020.variance.check.transformed}
homosc.table.char20 <- array(data=NA, dim=c(length(resp.char20), 2))
dimnames(homosc.table.char20)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.char20)[[1]] <- resp.char19

for (i in 1:length(resp.char20)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- with(chardonnay2020_logged, 
                               bartlett.test(eval(parse(text=resp.char20[i])) ~ paste(treatment, block)))$p.value
  lev.p  <- with(chardonnay2020_logged, 
                        levene.test(eval(parse(text=resp.char20[i])), paste(treatment, block)))$p.value
  homosc.table.char20[i,1] <- bart.p
  homosc.table.char20[i,2] <- lev.p
}

for (i in 1:length(resp.char20)) {
  boxplot(chardonnay2020_logged[[resp.char20[i]]] ~ chardonnay2020_logged$treatment + chardonnay2020_logged$block,
        xlab="Treatment + Block")
}

homosc.table.char20
```

```{r merlot2019.normality.check}
resp.mer19 <- colnames(merlot2019)[-c(1:5, 7)]
# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer19 <- array(NA, c(12, length(resp.mer19)))
colnames(norm.tests.mer19) <- resp.mer19
rownames(norm.tests.mer19) <- unique(paste(merlot2019$block, merlot2019$treatment))[order(unique(paste(merlot2019$block, merlot2019$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2019 dataset
for (i in 1:length(resp.mer19)) {
  shapiro.results <- with(merlot2019, {lapply(split(eval(parse(text=resp.mer19[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:12) {norm.tests.mer19[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer19<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer19)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer19)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2019[which(paste(merlot2019$block, merlot2019$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2019[which(paste(merlot2019$block, merlot2019$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.mer19
```

```{r merlot2019.variance.check}
# Create some tables to save the results of our statistical tests in
homosc.table.mer19 <- array(data=NA, dim=c(length(resp.mer19), 2))
dimnames(homosc.table.mer19)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.mer19)[[1]] <- resp.mer19

# Compare variances for each unique treatment-block group
for (i in 1:length(resp.mer19)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- (with(merlot2019,
                        bartlett.test(eval(parse(text=resp.mer19[i])) ~ paste(treatment, block)))$p.value)
  lev.p  <- (with(merlot2019,
                        levene.test(eval(parse(text=resp.mer19[i])), paste(treatment, block)))$p.value)
  homosc.table.mer19[i,1] <- bart.p
  homosc.table.mer19[i,2] <- lev.p
}

for (i in 1:length(resp.mer19)) {
  boxplot(merlot2019[[resp.mer19[i]]] ~ merlot2019$treatment + merlot2019$block,
        xlab="Treatment + Block")
}

homosc.table.mer19
```


```{r merlot2019.normality.check.transformed}
merlot2019_logged = merlot2019
merlot2019_logged[,-c(1:5)] = log(merlot2019_logged[,-c(1:5)])

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer19 <- array(NA, c(12, length(resp.mer19)))
colnames(norm.tests.mer19) <- resp.mer19
rownames(norm.tests.mer19) <- unique(paste(merlot2019$block, merlot2019$treatment))[order(unique(paste(merlot2019$block, merlot2019$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2019 dataset
for (i in 1:length(resp.mer19)) {
  shapiro.results <- with(merlot2019_logged, {lapply(split(eval(parse(text=resp.mer19[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:12) {norm.tests.mer19[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer19<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer19)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer19)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2019_logged[which(paste(merlot2019_logged$block, merlot2019_logged$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2019_logged[which(paste(merlot2019_logged$block, merlot2019_logged$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.mer19
```

```{r merlot2019.variance.check.transformed}
# Create some tables to save the results of our statistical tests in
homosc.table.mer19 <- array(data=NA, dim=c(length(resp.mer19), 2))
dimnames(homosc.table.mer19)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.mer19)[[1]] <- resp.mer19

# Compare variances for each unique treatment-block group
for (i in 1:length(resp.mer19)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- (with(merlot2019_logged,
                        bartlett.test(eval(parse(text=resp.mer19[i])) ~ paste(treatment, block)))$p.value)
  lev.p  <- (with(merlot2019_logged,
                        levene.test(eval(parse(text=resp.mer19[i])), paste(treatment, block)))$p.value)
  homosc.table.mer19[i,1] <- bart.p
  homosc.table.mer19[i,2] <- lev.p
}

for (i in 1:length(resp.mer19)) {
  boxplot(merlot2019_logged[[resp.mer19[i]]] ~ merlot2019_logged$treatment + merlot2019_logged$block,
        xlab="Treatment + Block")
}

homosc.table.mer19
```

```{r merlot2020.normality.check}
# remove veraison, bloom, brown seed color, ravaz index, and pruning weight
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7,9, 18:20)]

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer20 <- array(NA, c(12, length(resp.mer20)))
colnames(norm.tests.mer20) <- resp.mer20
rownames(norm.tests.mer20) <- unique(paste(merlot2020$block, merlot2020$treatment))[order(unique(paste(merlot2020$block, merlot2020$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2019 dataset
for (i in 1:length(resp.mer20)) {
  shapiro.results <- with(merlot2020, {lapply(split(eval(parse(text=resp.mer20[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:12) {norm.tests.mer20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2020[which(paste(merlot2020$block, merlot2020$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2020[which(paste(merlot2020$block, merlot2020$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.mer20
```

```{r merlot2020.variance.check}
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7,9)]
# Create some tables to save the results of our statistical tests in
homosc.table.mer20 <- array(data=NA, dim=c(length(resp.mer20), 2))
dimnames(homosc.table.mer20)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.mer20)[[1]] <- resp.mer20

# Compare variances for each unique treatment-block group
for (i in 1:length(resp.mer20)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- (with(merlot2020,
                        bartlett.test(eval(parse(text=resp.mer20[i])) ~ paste(treatment, block)))$p.value)
  lev.p  <- (with(merlot2020,
                        levene.test(eval(parse(text=resp.mer20[i])), paste(treatment, block)))$p.value)
  homosc.table.mer20[i,1] <- bart.p
  homosc.table.mer20[i,2] <- lev.p
}

for (i in 1:length(resp.mer20)) {
  boxplot(merlot2020[[resp.mer20[i]]] ~ merlot2020$treatment + merlot2020$block,
        xlab="Treatment + Block")
}

homosc.table.mer20
```

```{r merlot2020.normality.check.transformed}
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7,9, 18:20)]
merlot2020_logged = merlot2020
merlot2020_logged[,-c(1:5)] = log1p(merlot2020_logged[,-c(1:5)])

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer20 <- array(NA, c(12, length(resp.mer20)))
colnames(norm.tests.mer20) <- resp.mer20
rownames(norm.tests.mer20) <- unique(paste(merlot2020$block, merlot2020$treatment))[order(unique(paste(merlot2020$block, merlot2020$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2020 dataset
for (i in 1:length(resp.mer20)) {
  shapiro.results <- with(merlot2020_logged, {lapply(split(eval(parse(text=resp.mer20[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:12) {norm.tests.mer20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2020_logged[which(paste(merlot2020_logged$block, merlot2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2020_logged[which(paste(merlot2020_logged$block, merlot2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.mer20

```

```{r merlot2020.variance.check.transformed}
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7,9)]
# Create some tables to save the results of our statistical tests in
homosc.table.mer20 <- array(data=NA, dim=c(length(resp.mer20), 2))
dimnames(homosc.table.mer20)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.mer20)[[1]] <- resp.mer20

# Compare variances for each unique treatment-block group
for (i in 1:length(resp.mer20)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- (with(merlot2020_logged,
                        bartlett.test(eval(parse(text=resp.mer20[i])) ~ paste(treatment, block)))$p.value)
  lev.p  <- (with(merlot2020_logged,
                        levene.test(eval(parse(text=resp.mer20[i])), paste(treatment, block)))$p.value)
  homosc.table.mer20[i,1] <- bart.p
  homosc.table.mer20[i,2] <- lev.p
}

for (i in 1:length(resp.mer20)) {
  boxplot(merlot2020_logged[[resp.mer20[i]]] ~ merlot2020_logged$treatment + merlot2020_logged$block,
        xlab="Treatment + Block")
}

homosc.table.mer20
```

```{r merlot2020.brown.seed.color.assumption}
split = with(merlot2020, split(eval(parse(text="brown.seed.color")), 
              paste0(block, treatment)))
split = split[-6]
shapiro.results <- with(merlot2020, {lapply(split, shapiro.test)})

norm.tests.mer20 <- array(NA, c(11,1))
colnames(norm.tests.mer20) <- c("brown.seed.color")
names = unique(paste(merlot2020$block, merlot2020$treatment))[order(unique(paste(merlot2020$block, merlot2020$treatment)))]
names = names[-6]
rownames(norm.tests.mer20) <- names

for (k in 1:11) {norm.tests.mer20[k] <- shapiro.results[[k]]$p.value}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2020[which(paste(merlot2020$block, merlot2020$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2020[which(paste(merlot2020$block, merlot2020$treatment)==non.norm[i,1]),non.norm[i,2]])
}
norm.tests.mer20

# log transform
split = with(merlot2020_logged, split(eval(parse(text="brown.seed.color")), 
              paste0(block, treatment)))
split = split[-6]
shapiro.results <- with(merlot2020_logged, {lapply(split, shapiro.test)})

norm.tests.mer20 <- array(NA, c(11,1))
colnames(norm.tests.mer20) <- c("brown.seed.color")
names = unique(paste(merlot2020$block, merlot2020$treatment))[order(unique(paste(merlot2020$block, merlot2020$treatment)))]
names = names[-6]
rownames(norm.tests.mer20) <- names

for (k in 1:11) {norm.tests.mer20[k] <- shapiro.results[[k]]$p.value}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2020_logged[which(paste(merlot2020_logged$block, merlot2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2020_logged[which(paste(merlot2020_logged$block, merlot2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]])
}
norm.tests.mer20
```

```{r merlot2020.pruning.weight.ravaz.index.assumption}
resp.mer20 <- colnames(merlot2020)[c(19:20)]

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer20 <- array(NA, c(8, length(resp.mer20)))
colnames(norm.tests.mer20) <- resp.mer20
names = unique(paste(merlot2020$block, merlot2020$treatment))[order(unique(paste(merlot2020$block, merlot2020$treatment)))]
names = names[-c(1:4)]
rownames(norm.tests.mer20) <- names

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2020 dataset
for (i in 1:length(resp.mer20)) {
  split = with(merlot2020, split(eval(parse(text=resp.mer20[i])), paste0(block, treatment)))
  split = split[-c(1:4)]
  shapiro.results <- with(merlot2020, {lapply(split, shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:8) {norm.tests.mer20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  i=1
  qqnorm(merlot2020[which(paste(merlot2020$block, merlot2020$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2020[which(paste(merlot2020$block, merlot2020$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.mer20

# log transformed 
# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer20 <- array(NA, c(8, length(resp.mer20)))
colnames(norm.tests.mer20) <- resp.mer20
names = unique(paste(merlot2020$block, merlot2020$treatment))[order(unique(paste(merlot2020$block, merlot2020$treatment)))]
names = names[-c(1:4)]
rownames(norm.tests.mer20) <- names

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2020 dataset
for (i in 1:length(resp.mer20)) {
  split = with(merlot2020, split(eval(parse(text=resp.mer20[i])), paste0(block, treatment)))
  split = split[-c(1:4)]
  shapiro.results <- with(merlot2020, {lapply(split, shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:8) {norm.tests.mer20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2020_logged[which(paste(merlot2020_logged$block, merlot2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2020_logged[which(paste(merlot2020_logged$block, merlot2020_logged$treatment)==non.norm[i,1]),non.norm[i,2]])
}

norm.tests.mer20
```

```{r two.way.anova.chardonnay2019}
resps = colnames(chardonnay2019)[6:8]

for (i in 1:length(resps)) {
  print(resps[i])
  options(contrasts = c("contr.sum", "contr.poly"))
  resres = aov(eval(parse(text=resps[i])) ~ treatment * block, data=chardonnay2019)

  options(contrasts = c("contr.sum", "contr.poly"))
  library(car)
  resresres = Anova(resres, type = "III")
  print(resresres)
}
```

```{r two.way.anova.chardonnay2020}
resps = colnames(chardonnay2020)[6:8]

for (i in 1:length(resps)) {
  print(resps[i])
  options(contrasts = c("contr.sum", "contr.poly"))
  resres = aov(eval(parse(text=resps[i])) ~ treatment * block, data=chardonnay2020)

  options(contrasts = c("contr.sum", "contr.poly"))
  library(car)
  resresres = Anova(resres, type = "III")
  print(resresres)
}
```

```{r two.way.anova.merlot2019}
resps = resp.mer19

for (i in 1:length(resps)) {
  print(resps[i])
  options(contrasts = c("contr.sum", "contr.poly"))
  resres = aov(eval(parse(text=resps[i])) ~ treatment * block, data=merlot2019)
  
  options(contrasts = c("contr.sum", "contr.poly"))
  library(car)
  resresres = Anova(resres, type = "III")
  print(resresres)
}
```

```{r two.way.anova.merlot2020}
resps = resp.mer20

for (i in 1:length(resps)) {
  print(resps[i])
  options(contrasts = c("contr.sum", "contr.poly"))
  resres = aov(eval(parse(text=resps[i])) ~ treatment * block, data=merlot2020)
  
  options(contrasts = c("contr.sum", "contr.poly"))
  library(car)
  resresres = Anova(resres, type = "III")
  print(resresres)
}
```

```{r two.way.merlot2020.pruning.weight.ravaz.index}
block12_removed = merlot2020[which(merlot2020$block != "1" & merlot2020$block != "2"),]

print("pruning.weight")
options(contrasts = c("contr.sum", "contr.poly"))
resres = aov(pruning.weight ~ treatment * block, data=block12_removed)

options(contrasts = c("contr.sum", "contr.poly"))
library(car)
resresres = Anova(resres, type = "III")
print(resresres)

print("Ravaz.index")
options(contrasts = c("contr.sum", "contr.poly"))
resres = aov(Ravaz.index ~ treatment * block, data=block12_removed)

options(contrasts = c("contr.sum", "contr.poly"))
library(car)
resresres = Anova(resres, type = "III")
print(resresres)
```