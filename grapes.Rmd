---
title: "Grapevine"
author: "Naitong Chen, Shirley Cui, Shannon Edie"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data description

```{r, include=FALSE}
merlot2020 = read.csv("TanjaVoegel_Merlot_2020_data.csv")
merlot2019 = read.csv("TanjaVoegel_Merlot_2019_data.csv")
chardonnay2019 = read.csv("TanjaVoegel_Chardonnay_2019_data.csv")
chardonnay2020 = read.csv("TanjaVoegel_Chardonnay_2020_data.csv")

# removing extra columns
merlot2020 = merlot2020[-(61:65),]
merlot2020 = merlot2020[,-(19:20)]
merlot2019 = merlot2019[-(61:65),]
merlot2019 = merlot2019[,-18]

# encode row, treatment, block, and subsample as factor
chardonnay2019$row = as.factor(chardonnay2019$row)
chardonnay2019$treatment = as.factor(chardonnay2019$treatment)
chardonnay2019$block = as.factor(chardonnay2019$block)
chardonnay2019$subsample = as.factor(chardonnay2019$subsample)

chardonnay2020$row = as.factor(chardonnay2020$row)
chardonnay2020$treatment = as.factor(chardonnay2020$treatment)
chardonnay2020$block = as.factor(chardonnay2020$block)
chardonnay2020$subsample = as.factor(chardonnay2020$subsample)

merlot2019$row = as.factor(merlot2019$row)
merlot2019$treatment = as.factor(merlot2019$treatment)
merlot2019$block = as.factor(merlot2019$block)
merlot2019$subsample = as.factor(merlot2019$subsample)

merlot2020$row = as.factor(merlot2020$row)
merlot2020$treatment = as.factor(merlot2020$treatment)
merlot2020$block = as.factor(merlot2020$block)
merlot2020$subsample = as.factor(merlot2020$subsample)
```

## Chardonnay

There are 40 samples in each of the chardonnay2019 and chardonnay2020 data set. The 40 samples consist of 8 samples from each of the 5 blocks. Among the 8 samples within each block, 4 samples of each treatment are included.

Both datasets contain 3 measurements of each sample with no missing data.

```{r, echo=FALSE}
print(chardonnay2020[0,])
```

## Merlot

There are 60 samples in each of the merlot2019 and merlot2020 data set. The 60 samples consist of 10 samples from each of the 6 blocks. Among the 10 samples within each block, 5 samples of each treatment are included.

There are 10 measurements that are common between the two merlot data sets. In addition, merlot2020 contains measures of fruitfulness, bloom, and brown seed color. merlot2019 contains measures of pruning weight and ravaz index.

In the merlot2019 data set, there are missing values from the measurement of veraison. In the merlot2020 data set, there are missing vales from the measurements of veraison, bloom, yield, cluster weight, berries/cluster, berry weight, berry Brix, berry TA, berry pH, and brown seed color.

```{r, echo=FALSE}
print(merlot2019[0,])
print(merlot2020[0,])
```

# Missing data in merlot2019 and merlot2020

## Veraison

We know from the client that the veraison column indicates the number days into August in each respective year when 50% of the berries on a given vine had reached 50%. The missing entries are a result of the vines reaching 50% veraison on the first day of measurement. They are missing not at random (MNAR) as whether this value is missing for each vine is dependent on this particular value. More specifically, if any of the missing values were recorded, it must be negative.

While imputation seems like a reasonable approach, since we know these values must be negative, we can take the maximum between each imputed value and zero to produce complete data sets?

Percentage of missing for the veraison measure of merlot2019 and merlot2020 are shown below.

```{r, echo=FALSE}
c(mean(is.na(merlot2019$veraison)), mean(is.na(merlot2020$veraison)))
```

## Bloom

Similar to veraison, the bloom column includes values that that indicate the number of days into June in each respective year when 50% of the flowers on a given vine had started to bloom. The missing entries are a result of the vines reaching 50% bloom on the first day of measurement. They are also missing not at random (MNAR). 

Again, we can consider taking the maximum between each imputed value and zero to produce complete data sets.

Percentage of missing for the bloom measure of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$bloom))
```

## Yield related measures

For all columns that contain missing values (yield, cluster weight, berries/cluster, berry weight), the reason for missing is that the vine had no yield. Even though these missing values depend on the measures of cluster number of their corresponding vines being zero, these yield related values are missing precisely because there are no yield. This is then also a case of missing not at random (MNAR). 

Assigning these missing entries the value of zero seems plausible.

Percentage of missing for the yield related measures of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$yield))
```

## Berry related measures

Similarly, for all columns that contain missing values (berry Brix, berry TA, berry pH, brown seed color), the reason for missing is that the vine had no yield. These values are missing simply because there were no grapes produced to have these measurements recorded. Depending on the relationship between berry quality and yield, this is either a case of missing at random (MAR, in the absence of an association between berry quality and yield) or missing completely at random (MCAR, in the presence of an association between berry quality and yield). 

Due to the structure of the study, particularly the existence of blocking and replication, imputation seems to be the most reasonable approach to fill in the missing values.

Percentage of missing for the berry related measures of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$berry.Brix))
```

## Question

In the merlot2020 data set, most of the vines that had no entries for bloom or veraison (implying earlier ripening) also had no yield. This is against my intuition. If anything, as observed in the other three data sets, early ripening may be associated with higher yield? What was the weather event that caused some of the vines to have no yield?

# Constructing complete data sets

We construct complete data sets using the approaches described above. Once these complete data sets are constructed, analysis can be done separately on each of the imputed data sets. Although we need to look into the necessity and methods to aggregate these results. We should also look into the order or columns to impute, as well as whether all responses should be used to predict the missing values.

For now, I have imputed with and without the yield related measures. We may consider more variants such as using only responses that are highly correlated.

Linear regerssions are used for imputation. There are a lot more available options specified on page 76 of https://cran.r-project.org/web/packages/mice/mice.pdf.

Note that the the columns of key, row and subsample are excluded from all imputations below.

## merlot2019

The imputed values of veraison for merlot2019 from the first imputed data set are shown below. Note they are all above zero, they will all be filled in with zero before the analysis.

```{r, include=FALSE}
# load mice
library(mice)

# imputing veraison for merlot2019 using all responses (exclusing key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2019)^2), ncol(merlot2019), ncol(merlot2019))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2019mice = mice(data = merlot2019, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

```{r, echo=FALSE}
# checking imputed values
merlot2019full_1 = complete(merlot2019mice, 1)
print(merlot2019full_1$veraison[is.na(merlot2019$veraison)])
```

## merlot2020

```{r, include=FALSE}
# filling in zero for yield related entries
merlot2020$yield[is.na(merlot2020$yield)] = 0
merlot2020$cluster.weight[is.na(merlot2020$cluster.weight)] = 0
merlot2020$berries.cluster[is.na(merlot2020$berries.cluster)] = 0
merlot2020$berry.weight[is.na(merlot2020$berry.weight)] = 0

# imputation for merlot2020 using all responses (excluding key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")

# imputation for merlot2020 not using yield related columns (also excluding key, row and subsample)
predMatrix[,c(11,14)] = 0
merlot2020miceNoYield = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

The first set of imputed values for merlot2020 using all responses are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020mice, 1)

print("veraison")
print(merlot2020full_1$veraison[is.na(merlot2020$veraison)])

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

The first set of imputed values for merlot2020 not using yield related measures are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020miceNoYield, 1)

print("veraison")
print(merlot2020full_1$veraison[is.na(merlot2020$veraison)])

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

Again the veraison values are all above zero, and so zero values will assigned before conducting the analysis.

We therefore won't need to do imputation on veraison altogether, and so can proceed for now using the following three sets of data (merlot2019, merlot2020 imputed with filled-in zeros, merlot2020 imputed without filled-in zeros).

```{r, include=FALSE}
merlot2019$veraison[is.na(merlot2019$veraison)] = 0

merlot2020$veraison[is.na(merlot2020$veraison)] = 0

predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")

predMatrix[,c(11,14)] = 0
predMatrix[,9] = 0
merlot2020miceNoZero = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

Check out the imputed data sets in the code blocks!

```{r, include=FALSE}
merlot2019 # this is now complete
complete(merlot2020mice, 1) # first (out of 5) imputed data set for merlot2020 using all responses including the filled-in zeros
complete(merlot2020miceNoZero, 1) # first (out of 5) imputed data set for merlot2020 without the filled-in zeros
```