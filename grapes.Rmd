---
title: "Grapevine"
author: "Naitong Chen, Shirley Cui, Shannon Edie"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(corrplot)
```

# Data description

```{r, include=FALSE}
merlot2020 = read.csv("TanjaVoegel_Merlot_2020_data.csv")
merlot2019 = read.csv("TanjaVoegel_Merlot_2019_data.csv")
chardonnay2019 = read.csv("TanjaVoegel_Chardonnay_2019_data.csv")
chardonnay2020 = read.csv("TanjaVoegel_Chardonnay_2020_data.csv")

# removing extra columns
merlot2020 = merlot2020[-(61:65),]
merlot2020 = merlot2020[,-(19:20)]
merlot2019 = merlot2019[-(61:65),]
merlot2019 = merlot2019[,-18]

# encode row, treatment, block, and subsample as factor
chardonnay2019$row = as.factor(chardonnay2019$row)
chardonnay2019$treatment = as.factor(chardonnay2019$treatment)
chardonnay2019$block = as.factor(chardonnay2019$block)
chardonnay2019$subsample = as.factor(chardonnay2019$subsample)

chardonnay2020$row = as.factor(chardonnay2020$row)
chardonnay2020$treatment = as.factor(chardonnay2020$treatment)
chardonnay2020$block = as.factor(chardonnay2020$block)
chardonnay2020$subsample = as.factor(chardonnay2020$subsample)

merlot2019$row = as.factor(merlot2019$row)
merlot2019$treatment = as.factor(merlot2019$treatment)
merlot2019$block = as.factor(merlot2019$block)
merlot2019$subsample = as.factor(merlot2019$subsample)

merlot2020$row = as.factor(merlot2020$row)
merlot2020$treatment = as.factor(merlot2020$treatment)
merlot2020$block = as.factor(merlot2020$block)
merlot2020$subsample = as.factor(merlot2020$subsample)
```

## Chardonnay

There are 40 samples in each of the chardonnay2019 and chardonnay2020 data set. The 40 samples consist of 8 samples from each of the 5 blocks. Among the 8 samples within each block, 4 samples of each treatment are included.

Both datasets contain 3 measurements of each sample with no missing data.

```{r, echo=FALSE}
print(chardonnay2020[0,])
```

## Merlot

There are 60 samples in each of the merlot2019 and merlot2020 data set. The 60 samples consist of 10 samples from each of the 6 blocks. Among the 10 samples within each block, 5 samples of each treatment are included.

There are 10 measurements that are common between the two merlot data sets. In addition, merlot2020 contains measures of fruitfulness, bloom, and brown seed color. merlot2019 contains measures of pruning weight and ravaz index.

In the merlot2019 data set, there are missing values from the measurement of veraison. In the merlot2020 data set, there are missing vales from the measurements of veraison, bloom, yield, cluster weight, berries/cluster, berry weight, berry Brix, berry TA, berry pH, and brown seed color.

```{r, echo=FALSE}
print(merlot2019[0,])
print(merlot2020[0,])
```

# Missing data in merlot2019 and merlot2020

## Veraison

We know from the client that the veraison column indicates the number days into August in each respective year when 50% of the berries on a given vine had changed to red. The missing entries are a result of the vines reaching 50% veraison on the first day of measurement. They are missing not at random (MNAR) as whether this value is missing for each vine is dependent on this particular value. More specifically, if any of the missing values were recorded, it must be negative.

While imputation seems like a reasonable approach, since we know these values must be negative, we can take the maximum between each imputed value and zero to produce complete data sets?

Percentage of missing for the veraison measure of merlot2019 and merlot2020 are shown below.

```{r, echo=FALSE}
c(mean(is.na(merlot2019$veraison)), mean(is.na(merlot2020$veraison)))
```

## Bloom

Similar to veraison, the bloom column includes values that indicate the number of days into June in each respective year when 50% of the flowers on a given vine had started to bloom. The missing entries are a result of the vines reaching 50% bloom on the first day of measurement. They are also missing not at random (MNAR). 

Again, we can consider taking the maximum between each imputed value and zero to produce complete data sets.

Percentage of missing for the bloom measure of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$bloom))
```

## Yield related measures

For all columns that contain missing values (yield, cluster weight, berries/cluster, berry weight), the reason for missing is that the vine had no yield. Even though these missing values depend on the measures of cluster number of their corresponding vines being zero, these yield related values are missing precisely because there are no yield. This is then also a case of missing not at random (MNAR). 

Assigning these missing entries the value of zero seems plausible.

Percentage of missing for the yield related measures of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$yield))
```

## Berry related measures

Similarly, for all columns that contain missing values (berry Brix, berry TA, berry pH, brown seed color), the reason for missing is that the vine had no yield. These values are missing simply because there were no grapes produced to have these measurements recorded. Depending on the relationship between berry quality and yield, this is either a case of missing at random (MAR, in the absence of an association between berry quality and yield) or missing completely at random (MCAR, in the presence of an association between berry quality and yield). 

Due to the structure of the study, particularly the existence of blocking and replication, imputation seems to be the most reasonable approach to fill in the missing values.

Percentage of missing for the berry related measures of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$berry.Brix))
```

## Question

In the merlot2020 data set, most of the vines that had no entries for bloom or veraison (implying earlier ripening) also had no yield. This is against my intuition. If anything, as observed in the other three data sets, early ripening may be associated with higher yield? What was the weather event that caused some of the vines to have no yield?

# Constructing complete data sets

We construct complete data sets using the approaches described above. Once these complete data sets are constructed, analysis can be done separately on each of the imputed data sets. Although we need to look into the necessity and methods to aggregate these results. We should also look into the order or columns to impute, as well as whether all responses should be used to predict the missing values.

For now, I have imputed with and without the yield related measures. We may consider more variants such as using only responses that are highly correlated.

Linear regerssions are used for imputation. There are a lot more available options specified on page 76 of https://cran.r-project.org/web/packages/mice/mice.pdf.

Note that the the columns of key, row and subsample are excluded from all imputations below.

## merlot2019

The imputed values of veraison for merlot2019 from the first imputed data set are shown below. Note they are all above zero, they will all be filled in with zero before the analysis.

```{r, include=FALSE}
# load mice
library(mice)

# imputing veraison for merlot2019 using all responses (exclusing key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2019)^2), ncol(merlot2019), ncol(merlot2019))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2019mice = mice(data = merlot2019, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

```{r, echo=FALSE}
# checking imputed values
merlot2019full_1 = complete(merlot2019mice, 1)
print(merlot2019full_1$veraison[is.na(merlot2019$veraison)])
```

## merlot2020

```{r, include=FALSE}
# filling in zero for yield related entries
merlot2020$yield[is.na(merlot2020$yield)] = 0
merlot2020$cluster.weight[is.na(merlot2020$cluster.weight)] = 0
merlot2020$berries.cluster[is.na(merlot2020$berries.cluster)] = 0
merlot2020$berry.weight[is.na(merlot2020$berry.weight)] = 0

# imputation for merlot2020 using all responses (excluding key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")

# imputation for merlot2020 not using yield related columns (also excluding key, row and subsample)
predMatrix[,c(11,14)] = 0
merlot2020miceNoYield = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

The first set of imputed values for merlot2020 using all responses are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020mice, 1)

print("veraison")
print(merlot2020full_1$veraison[is.na(merlot2020$veraison)])

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

The first set of imputed values for merlot2020 not using yield related measures are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020miceNoYield, 1)

print("veraison")
print(merlot2020full_1$veraison[is.na(merlot2020$veraison)])

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

Again the veraison values are all above zero, and so zero values will assigned before conducting the analysis.

We therefore won't need to do imputation on veraison altogether, and so can proceed for now using the following three sets of data (merlot2019, merlot2020 imputed with filled-in zeros, merlot2020 imputed without filled-in zeros).

```{r, include=FALSE}
merlot2019$veraison[is.na(merlot2019$veraison)] = 0

merlot2020$veraison[which(is.na(merlot2020$veraison) & merlot2020$cluster.number > 0)] = 0

predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")

# predMatrix[,c(11,14)] = 0
# predMatrix[,9] = 0
# merlot2020miceNoZero = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

Check out the imputed data sets in the code blocks!

```{r, include=FALSE}
merlot2019 # this is now complete
complete(merlot2020mice, 1) # first (out of 5) imputed data set for merlot2020 using all responses including the filled-in zeros
# complete(merlot2020miceNoZero, 1) # first (out of 5) imputed data set for merlot2020 without the filled-in zeros
```

## data preprocessing - PCA
Basically, we have reduced the dimentions of the dataset down to four/three dimensions for merlot 2013/2014 using PCA.
```{r, include=FALSE}
# carry forward with the following data sets (response variables only)
char2019.resp <- select(chardonnay2019,(-1:-5))
char2020.resp <- select(chardonnay2020, (-1:-5))
merlot2019.resp <- select(merlot2019,(-1:-5))
merlot2020.resp <- select(complete(merlot2020mice, 1),(-1:-5))
```

```{r, include=FALSE}
# extracting features
# 2019
merlot2019.growth <- select(merlot2019.resp,(1:2))
res <- prcomp(merlot2019.growth, center = TRUE, scale = TRUE)
merlot2019.growth.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9577232

merlot2019.yield <- select(merlot2019.resp,(3:7))
res <- prcomp(merlot2019.yield, center = TRUE, scale = TRUE)
merlot2019.yield.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9741755

merlot2019.quality <- select(merlot2019.resp,(8:10))
res <- prcomp(merlot2019.quality, center = TRUE, scale = TRUE)
merlot2019.quality.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.78826

merlot2019.pruning <- select(merlot2019.resp,(11:12))
res <- prcomp(merlot2019.pruning, center = TRUE, scale = TRUE)
merlot2019.pruning.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9996358

# 2020
merlot2020.growth <- select(merlot2020.resp,c(1:4,13))
res <- prcomp(merlot2020.growth, center = TRUE, scale = TRUE)
merlot2020.growth.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.7180542

merlot2020.yield <- select(merlot2020.resp,(5:9))
res <- prcomp(merlot2020.yield, center = TRUE, scale = TRUE)
merlot2020.yield.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9821489

merlot2020.quality <- select(merlot2020.resp,(10:12))
res <- prcomp(merlot2020.quality, center = TRUE, scale = TRUE)
merlot2020.quality.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.8134009
```


```{r, include=FALSE}
# putting together extracted datasets
merlot2019.pca = cbind(merlot2019[-61:-65, 1:5], merlot2019.growth.pc, merlot2019.yield.pc,
                            merlot2019.quality.pc, merlot2019.pruning.pc)
merlot2019.pca = data.frame(merlot2019.pca)

merlot2020.pca = cbind(merlot2020[-61:-65, 1:5], merlot2020.growth.pc, merlot2020.yield.pc,
                            merlot2020.quality.pc)
merlot2020.pca = data.frame(merlot2020.pca)
```

```{r, include=FALSE}
# Now proceed with analysis using the following data sets
chardonnay2019
chardonnay2020
merlot2019.pca
merlot2020.pca
```

# Check for correlations
## Chardonnay dataset
### chardonnay 2019
```{r}
chardonnay2019 %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
From the output of correlation function, there seem no correlations between response variables.

### chardonnay 2020
```{r}
chardonnay2020 %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
Yield is found to be positively correlated with number of clusters.

### merlot 2019
```{r}
merlot2019.pca %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
### merlot 2020
```{r}
merlot2020.pca %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
From the correlation matrix plots, there seem to be no obvious correlations among the response variables in these four datasets. We are good to continue with normality and equal variance assumptions check.

## Check for assumption of ANOVA test: normality and equal variance
### Chardonnay 2019 
1. table of mean and variance under control and treatment for each response variable
```{r}
chardonnay2019 %>% 
  group_by(block, treatment) %>% 
  summarise(var.num_of_cluster=var(X..of.clusters),
            mean.num_of_cluster=mean(X..of.clusters),
            var.yield=var(yield..kg.),
            mean.yield=mean(yield..kg.),
            var.cluster_weight=var(av.cluster.weight..kg.),
            mean.cluster_weight=mean(av.cluster.weight..kg.))
```

2. Visualization (side by side boxplots for each response variable)
```{r}
## check assumptions of number of clusters
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = X..of.clusters, fill=treatment))+
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "number of clusters") +
  ylab("number of clusters")+
  facet_wrap(~block)

## check assumptions of yield
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = yield..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  ylab("yield")+
  facet_wrap(~block) 

## check assumptions for average cluster weight
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = av.cluster.weight..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "average cluster weight") +
  ylab("average cluster weight")+
  facet_wrap(~block) 
```
### Chardonnay 2020
1. table of mean and variance under control and treatment for each response variable
```{r}
chardonnay2020 %>% 
  group_by(block, treatment) %>% 
  summarise(var.num_of_cluster=var(X..of.clusters),
            mean.num_of_cluster=mean(X..of.clusters),
            var.yield=var(yield..kg.),
            mean.yield=mean(yield..kg.),
            var.cluster_weight=var(av.cluster.weight..kg.),
            mean.cluster_weight=mean(av.cluster.weight..kg.))
```
2. Visualization (side by side boxplots for each response variable)
```{r}
## check assumptions of number of clusters
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = X..of.clusters, fill=treatment))+
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "number of clusters") +
  ylab("number of clusters")+
  facet_wrap(~block)

## check assumptions of yield
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = yield..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  ylab("yield")+
  facet_wrap(~block) 

## check assumptions for average cluster weight
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = av.cluster.weight..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "average cluster weight") +
  ylab("average cluster weight")+
  facet_wrap(~block) 
```
### merlot 2019
1. table of mean and variance under control and treatment for each response variable
```{r}
merlot2019.pca %>% 
  group_by(block, treatment) %>% 
  summarise(var.growth=var(merlot2019.growth.pc),
            mean.growth=mean(merlot2019.growth.pc),
            var.yield=var(merlot2019.yield.pc),
            mean.yield=mean(merlot2019.yield.pc),
            var.quality=var(merlot2019.quality.pc),
            mean.quality=mean(merlot2019.quality.pc),
            var.yield=var(merlot2019.pruning.pc),
            mean.yield=mean(merlot2019.pruning.pc))

```

2. Visualization (side by side boxplots for each response variable)
```{r}
ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.growth.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "growth") +
  ylab("growth")+
  facet_wrap(~block) 

ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.yield.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  facet_wrap(~block) 

ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.quality.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "quality") +
  facet_wrap(~block) 

ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.pruning.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "pruning") +
  facet_wrap(~block) 
```

### merlot 2020
1. table of mean and variance under control and treatment for each response variable
```{r}
merlot2020.pca %>% 
  group_by(block, treatment) %>% 
  summarise(var.growth=var(merlot2020.growth.pc),
            mean.growth=mean(merlot2020.growth.pc),
            var.yield=var(merlot2020.yield.pc),
            mean.yield=mean(merlot2020.yield.pc),
            var.quality=var(merlot2020.quality.pc),
            mean.quality=mean(merlot2020.quality.pc))
```

2. Visualization (side by side boxplots for each response variable)
```{r}
ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.growth.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "growth") +
  ylab("growth")+
  facet_wrap(~block) 

ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.yield.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  facet_wrap(~block) 

ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.quality.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "quality") +
  facet_wrap(~block) 
```

Based on the side-by-side box plots above, it seems that many outcome variables do not have equal variance, or the distribution is not quite normal. One limitation which can explain this is that our sample size is really small for each treatment in each block(5 or 6 datapoints). Hence, the plot cannot really tell much useful information about the data. 

Below, wilcoxon rank tests can be performed to test whether the distribution in control and treatment groups are the same. (that would be a lot of tests... I only tried out the test for number of clusters in Char2019 for five blocks.)
### randomization test
chardonnay 2019
```{r}
for (i in unique(chardonnay2019$block)){
  res=wilcox.test(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"],
                  chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"],
                  exact=FALSE)
  print(res)
}
```

QQ plot for number of clusters in chardonnary 2019 (for each block/treatment combo)

```{r, echo=FALSE}
for (i in unique(chardonnay2019$block)){
  qqnorm(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
  qqline(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"], col = "red")
  qqnorm(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"])
  qqline(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"], col = "red")
}
```

F test and randomization test for equal variance between treatments for each block in chardonnary 2019
```{r, echo=FALSE}
for (i in unique(chardonnay2019$block)){
  res = var.test(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"], chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"])
  print("F test")
  print(res$p.value)
  
  # randomization test for equal variance
  n = 2*length(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
  n1 = length(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
  totalComb <- combn(n, n1)
  dim(totalComb)
  
  totalComb.complement <- matrix(nrow = dim(totalComb)[1], ncol = dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    totalComb.complement[,j] = (1:n)[-totalComb[,j]]
  }
  
  # replace the indices by the actual value.
  dat = chardonnay2019$X..of.clusters[chardonnay2019$block==i]
  dat.mat <- matrix(dat[totalComb], ncol = choose(n, n1))
  dat.mat.complement <- matrix(dat[totalComb.complement], ncol = choose(n, n1))
  
  # calculate the d_obs
  d.obs <- abs(var(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"]) - var(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"]))
  
  # calculate all other ds
  abs.diff.var <- rep(0, dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    abs.diff.var[j] = abs(var(dat.mat[,j]) - var(dat.mat.complement[,j]))
  }

  c1 <- sum(abs.diff.var > d.obs)
  c2 <- sum(abs.diff.var == d.obs)
  p.val <- (c1 + 0.5*c2)/choose(n, n1)
  print("rand test")
  print(p.val)
}
```

QQ plot for the growth PC in merlot 2020 (for each block/treatment combo)

```{r, echo=FALSE}
for (i in unique(merlot2020.pca$block)){
  qqnorm(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
  qqline(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"], col = "red")
  qqnorm(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"])
  qqline(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"], col = "red")
}
```

F test and randomization test for equal variance between treatments for each block in merlot 2020
```{r, echo=FALSE}
for (i in unique(merlot2020.pca$block)){
  res = var.test(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"], merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"])
  print("F test")
  print(res$p.value)
  
  # randomization test for equal variance
  n = 2*length(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
  n1 = length(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
  totalComb <- combn(n, n1)
  dim(totalComb)
  
  totalComb.complement <- matrix(nrow = dim(totalComb)[1], ncol = dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    totalComb.complement[,j] = (1:n)[-totalComb[,j]]
  }
  
  # replace the indices by the actual value.
  dat = merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i]
  dat.mat <- matrix(dat[totalComb], ncol = choose(n, n1))
  dat.mat.complement <- matrix(dat[totalComb.complement], ncol = choose(n, n1))
  
  # calculate the d_obs
  d.obs <- abs(var(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"]) - var(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"]))
  
  # calculate all other ds
  abs.diff.var <- rep(0, dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    abs.diff.var[j] = abs(var(dat.mat[,j]) - var(dat.mat.complement[,j]))
  }

  c1 <- sum(abs.diff.var > d.obs)
  c2 <- sum(abs.diff.var == d.obs)
  p.val <- (c1 + 0.5*c2)/choose(n, n1)
  print("rand test")
  print(p.val)
}
```

We see that the normality assumptions are slightly violated, and the equal variance assumptions are also violated even though we only compared variances between treatments within each block. Therefore we will use both a parametric and a non parametric test in the following analysis. (Should repeat the above for all other variables.)

# Aligned rank transform ANOVA (nonparametric test for two-way layout)

## Chardonnay 2019 number of clusters
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2019
model = art(X..of.clusters ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Chardonnay 2019 yield
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2019
model = art(yield..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Chardonnay 2019 average cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2019
model = art(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Chardonnay 2020 number of clusters
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(X..of.clusters ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Chardonnay 2020 yield
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(yield..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Chardonnay 2020 average cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2019 growth PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.growth.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2019 yield PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.yield.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2019 quality PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.quality.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2019 pruning PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.pruning.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2020 growth PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020.pca
model = art(merlot2020.growth.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2020 yield PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020.pca
model = art(merlot2020.yield.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

## Merlot 2020 quality PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020.pca
model = art(merlot2020.quality.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
```

None of the treatment effects are significant. Although some of the interaction effects are. Maybe heating only helps under certain geographical conditions? 

Another thing to check is the actual estimate of the treatment/blocking/interaction effects. We can also construct SEs of each of these effects.

Can also combine data from both years and do repeated measures ANOVA?