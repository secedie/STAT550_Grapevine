---
title: "Grapevine"
author: "Naitong Chen, Shirley Cui, Shannon Edie"
output:
  html_document:
    df_print: paged
  pdf_document: default
  word_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(ggpubr) 
library(corrplot)
library(icenReg) # for survival analysis
library(knitr)
library(lawstat) # for the levene test
library(rstatix) # for the repeated-measures ANOVA
library(plyr) # to combine 2019 and 2020 data
library(ARTool) # for aligned rank transform
library(maditr) # for dcast
```

# Problem overview

Agro-thermal heat-treatment technology in grapevines has been shown to increase yield, decrease the use of agro-chemicals used to fight pests, enhance wine quality and improve profits, but this technology has not been tested in the Okanagan Valley or Canada. Heat treatment is applied by driving a tractor through the vineyard rows that blows extreme heat into the canopy. During the growing seasons of 2019 and 2020, heat treatment was applied to a Merlot and a Chardonnay vineyard in the Okanagan valley six times during the growing season with application ten days apart from each other. Treatments were: (1) heat, and (2) control (no heat).

# Data description

A full description of the recorded variables in the Chardonnay and Merlot studies can be seen in Figure \ref{var.descr.table}. The blocking structure, sample sizes, and a brief overview of missing data are explained below.

```{r read.data.in, include=FALSE}
chardonnay2019 = read.csv("TanjaVoegel_Chardonnay_2019_data.csv")
chardonnay2020 = read.csv("TanjaVoegel_Chardonnay_2020_data.csv")
merlot2019 = read.csv("TanjaVoegel_Merlot_2019_data.csv")
merlot2020 = read.csv("TanjaVoegel_Merlot_2020_data.csv")
addition2021 = read.csv("data addition March 8 2021.csv")

# removing extra columns
merlot2020 = merlot2020[-(61:65),]
merlot2020 = merlot2020[,-(19:20)]
merlot2019 = merlot2019[-(61:65),]
merlot2019 = merlot2019[,-18]

# Make sure the merlot column names are consistent
colnames(merlot2020)[colnames(merlot2020)=="spad"] = "SPAD"

# encode row, treatment, block, and subsample as factor
chardonnay2019$row = as.factor(chardonnay2019$row)
chardonnay2019$treatment = as.factor(chardonnay2019$treatment)
chardonnay2019$block = as.factor(chardonnay2019$block)
chardonnay2019$subsample = as.factor(chardonnay2019$subsample)

chardonnay2020$row = as.factor(chardonnay2020$row)
chardonnay2020$treatment = as.factor(chardonnay2020$treatment)
chardonnay2020$block = as.factor(chardonnay2020$block)
chardonnay2020$subsample = as.factor(chardonnay2020$subsample)

merlot2019$row = as.factor(merlot2019$row)
merlot2019$treatment = as.factor(merlot2019$treatment)
merlot2019$block = as.factor(merlot2019$block)
merlot2019$subsample = as.factor(merlot2019$subsample)


merlot2020$row = as.factor(merlot2020$row)
merlot2020$treatment = as.factor(merlot2020$treatment)
merlot2020$block = as.factor(merlot2020$block)
merlot2020$subsample = as.factor(merlot2020$subsample)

# Add in the additional data
names(merlot2020)[1] <- "Key"
merlot2020 <- join(merlot2020, addition2021)

```

```{r var.descr.table, echo=FALSE}

var.descr <- read.csv("Variable_descriptions.csv")
kable(var.descr, caption="\\label{var.descr.table} Variable descriptions.")

```

There are 40 samples in each of the Chardonnay 2019 and Chardonnay 2020 datasets. The 40 samples consist of 8 samples from each of the 5 blocks. Among the 8 samples within each block, 4 samples of each treatment are included.

Both Chardonnay datasets contain 3 measurements of each sample with no missing data.

There are 60 samples in each of the Merlot 2019 and Merlot 2020 datasets. The 60 samples consist of 10 samples from each of the 6 blocks. Among the 10 samples within each block, 5 samples of each treatment are included.

In the Merlot 2019 data set, there are missing values from the measurement of veraison. In the Merlot 2020 data set, there are missing vales from the measurements of veraison, bloom, yield, cluster weight, berries/cluster, berry weight, berry Brix, berry TA, berry pH, and brown seed color.

```{r, include=FALSE}
# carry forward with the following data sets (response variables only)
char2019.resp <- select(chardonnay2019,(-1:-5))
char2020.resp <- select(chardonnay2020, (-1:-5))
merlot2019.resp <- select(merlot2019,(-1:-5))
merlot2020.resp <- select(merlot2020,(-1:-5))
```

# Check for correlations among response variables
### chardonnay 2019

```{r}
chardonnay2019 %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
From the output of correlation function, there seem no correlations between response variables.

### chardonnay 2020

```{r}
chardonnay2020 %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
Yield is found to be positively correlated with number of clusters.

### merlot 2019

```{r}
## correlation matrix before PCA
merlot2019.resp %>%
  drop_na() %>% 
  cor() %>%
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
1. cluster weight and berries cluster (0.94): berries cluster = cluster weight/berries weight)

2. yield and cluster weight(0.76): cluster weight = yield/number of clusters


### merlot 2020

```{r}
# correlation matrix before PCA
merlot2020.resp %>%
  drop_na() %>% 
  cor() %>%
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
1. cluster number and yield (0.92)

2. cluster weight and berries cluster (0.92)

3. berry TA and berry PH (0.75)


# Exploratory Data Analysis

Visualization (side by side boxplots for each response variable)
- distributions over treatment :heat/control
- ignore block for now (for a general view)


```{r}
plot_resp = function(data, resp){
  ggplot(data, aes(x=treatment, y = .data[[resp]], fill=treatment))+
    scale_fill_manual(values=c("lightblue2", "seashell2"))+
    ylab(" ") +
    xlab(" ") +
    labs(title = resp) +
    theme(legend.position = "none")+
    geom_boxplot()+
    stat_compare_means(method = "t.test", 
                       label.y = quantile(data[[resp]],prob=0.95))
}
```

## Chardonnay 2019

```{r}
plot_list1= lapply(colnames(char2019.resp), plot_resp, data = chardonnay2019)
ggarrange(plotlist = plot_list1)
```

## Chardonnay 2020

```{r}
plot_list2=lapply(colnames(char2020.resp),plot_resp, data=chardonnay2020)
ggarrange(plotlist = plot_list2)
```

## Merlot 2019

```{r}
plot_list3=lapply(colnames(merlot2019[-c(1:5)]), plot_resp, data=drop_na(merlot2019))
ggarrange(plotlist = plot_list3)
```

## Merlot 2020

```{r}
plot_list4=lapply(colnames(merlot2020[-c(1:5)]), plot_resp, data=drop_na(merlot2020))
ggarrange(plotlist = plot_list4, heights = 2)
```

# Handling missing data

As mentioned above, missing data was unique to the Merlot datasets. The Merlot2019 dataset had missing data for "Veraison" and "Bloom", and the Merlot2020 dataset had missing data for "Veraison", "Bloom", yield-related measures, and berry quality measures.

The way that missing data should be handled depends largely on the mechanism by which the data is missing. In this grapevine data, there are two mechanisms by which the data are missing: 
(1) Missing completely at random (MCAR). This is when the reason that the data is missing has nothing to do with the dataset in any way. If the data is MCAR, then we can deal with it by excluding it entirely from analysis, or through imputation, which will be discussed below. The non-missing data can be thought of as a random subsample of your original sample population.
(2) Missing at random (MAR). This is when the data is missing, but the mechanism for its missingness may depend on the other variables in the dataset. We cannot just exclude these missing data from the analysis, so imputation is a good strategy to deal with the data.

## Veraison

We know from the client that the veraison column indicates the number days into August in each respective year when 50% of the berries on a given vine had changed to red. If the corresponding cluster number is greater than zero, then the missing entries are a result of the vines reaching 50% veraison on the first day of measurement. They are missing not at random (MNAR) as whether this value is missing for each vine is dependent on this particular value. More specifically, if any of the missing values were recorded, it must be negative. If the corresponding cluster number is zero, then the missing entries are missing completely at random (MCAR) as there were no clusters to measure.

This will be handled using survival analysis.

Percentage of missing for the veraison measure of merlot2019 and merlot2020 are shown in Table \ref{missing.percent}.

```{r missing.percent, echo=FALSE}
kable(data.frame("Missing 2019"=paste0(round(mean(is.na(merlot2019$veraison)), 3)*100, "%"), 
                 "Missing 2020"=paste0(round(mean(is.na(merlot2020$veraison)), 3)*100), "%"),
      caption="\\label{missing.percent} Percentage of Veraison data that is missing in the 2019 and 2020 Merlot datasets.")
```

## Bloom

Similar to veraison, the bloom column includes values that indicate the number of days into June in each respective year when 50% of the flowers on a given vine had started to bloom. The missing entries are a result of the vines reaching 50% bloom on the first day of measurement. They are also missing not at random (MNAR). Since there is no information on whether each vine has flowers, we make the assumption that there are for the time being.

This will also be handled using survival analysis.

`r paste0(round(mean(is.na(merlot2020$bloom)), 3)*100, "%")` of the bloom data in the Merlot 2020 dataset is missing.

## Yield-related measures

For all columns that contain missing values (yield, cluster weight, berries/cluster, berry weight), the reason for missing is that the vine had no yield. Consequently, these data were not truly "missing"-- they have a "true" value of zero to indicate zero yield. 

`r paste0(round(mean(is.na(merlot2020$yield)), 3)*100, "%")` of the yield is missing in the Merlot 2020.


## Berry-related measures

Similarly, for all columns that contain missing values (berry Brix, berry TA, berry pH, brown seed color), the reason for missing is that the vine had no yield. These values are missing because there were no grapes produced to have these measurements recorded. However, the quality of the berry may actually be related to the other variables in the dataset, and the 

Due to the structure of the study, particularly the existence of blocking and replication, imputation seems to be the most reasonable approach to fill in the missing values.

`r paste0(round(mean(is.na(merlot2020$berry.Brix)), 3)*100, "%")` of the berry quality data in the Merlot 2020 dataset is missing.

## Pruning weight

Pruning weight was missing because the winery had started to prune canes before data could be collected; the mechanism of missingness here is MCAR. We can handle this either by 

## Ravaz Index

Ravaz Index was missing either because pruning weight was missing, or because yield was zero. If yield was zero, then Ravaz Index was set to zero. If Ravaz Index was missing because pruning weight was missing, then we treated this as MCAR.

# Constructing complete data sets

We construct complete data sets using the approaches described above. Once these complete data sets are constructed, analysis can be done separately on each of the imputed data sets. Although we need to look into the necessity and methods to aggregate these results. We should also look into the order or columns to impute, as well as whether all responses should be used to predict the missing values.

For now, I have imputed using the yield related measures. We may consider more variants such as using only responses that are highly correlated.

Linear regerssions are used for imputation. There are a lot more available options specified on page 76 of https://cran.r-project.org/web/packages/mice/mice.pdf.

Note that the the columns of key, row and subsample are excluded from all imputations below.

## merlot2020

```{r, include=FALSE}

library(mice)
# filling in zero for yield related entries
merlot2020$yield[is.na(merlot2020$yield)] = 0
merlot2020$cluster.weight[is.na(merlot2020$cluster.weight)] = 0
merlot2020$berries.cluster[is.na(merlot2020$berries.cluster)] = 0
merlot2020$berry.weight[is.na(merlot2020$berry.weight)] = 0
merlot2020$cluster.number[is.na(merlot2020$cluster.number)] = 0

# imputation for merlot2020 using all responses (excluding key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

The first set of imputed values for merlot2020 using all responses are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020mice, 1)

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

Check out the imputed data sets in the code blocks!

```{r, include=FALSE}
chardonnay2019 # comlpete
chardonnay2020 # complete
merlot2019 # this is now complete excluding veraison
merlot2020<-complete(merlot2020mice, 1) # first (out of 5) imputed data set for merlot2020 using all responses including the filled-in zeros
```

```{r, include=FALSE}
# carry forward with the following data sets (response variables only)
char2019.resp <- select(chardonnay2019,(-1:-5))
char2020.resp <- select(chardonnay2020, (-1:-5))
merlot2019.resp <- select(merlot2019,(-1:-5))
merlot2020.resp <- select(merlot2020,(-1:-5))
```

## Check for assumption of ANOVA test: normality and equal variance
### Chardonnay 2019 
1. table of mean and variance under control and treatment for each response variable
```{r}
char19.tab <- chardonnay2019 %>% 
  group_by(block, treatment) %>% 
  summarise(var.num_of_cluster=var(X..of.clusters),
            mean.num_of_cluster=mean(X..of.clusters),
            var.yield=var(yield..kg.),
            mean.yield=mean(yield..kg.),
            var.cluster_weight=var(av.cluster.weight..kg.),
            mean.cluster_weight=mean(av.cluster.weight..kg.))
kable(char19.tab, caption="\\label{char19.summary.table} Summary statistics for outcome variables in the Chardonnay 2019 dataset.")
```

3. Visualization (side by side boxplots for each response variable + block)

```{r}
## check assumptions of number of clusters
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = X..of.clusters, fill=treatment))+
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "number of clusters") +
  ylab("number of clusters")+
  facet_wrap(~block)

## check assumptions of yield
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = yield..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  ylab("yield")+
  facet_wrap(~block) 

## check assumptions for average cluster weight
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = av.cluster.weight..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "average cluster weight") +
  ylab("average cluster weight")+
  facet_wrap(~block) 
```
### Chardonnay 2020
1. table of mean and variance under control and treatment for each response variable

```{r}
char20.tab<-chardonnay2020 %>% 
  group_by(block, treatment) %>% 
  summarise(var.num_of_cluster=var(X..of.clusters),
            mean.num_of_cluster=mean(X..of.clusters),
            var.yield=var(yield..kg.),
            mean.yield=mean(yield..kg.),
            var.cluster_weight=var(av.cluster.weight..kg.),
            mean.cluster_weight=mean(av.cluster.weight..kg.))
kable(char20.tab, caption="\\label{char20.summary.table} Summary statistics for outcome variables in the Chardonnay 2019 dataset.")
```



3. Visualization (side by side boxplots for each response variable - block)
```{r}
## check assumptions of number of clusters
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = X..of.clusters, fill=treatment))+
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "number of clusters") +
  ylab("number of clusters")+
  facet_wrap(~block)

## check assumptions of yield
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = yield..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  ylab("yield")+
  facet_wrap(~block) 

## check assumptions for average cluster weight
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = av.cluster.weight..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "average cluster weight") +
  ylab("average cluster weight")+
  facet_wrap(~block) 
```
### merlot 2019

1. table of mean and variance under control and treatment for each response variable

```{r}
# mer19.tab<-merlot2019 %>% 
#   group_by(block, treatment) %>% 
#   summarise(var.SPAD=var(merlot2019.growth.pc),
#             mean.growth=mean(merlot2019.growth.pc),
#             var.yield=var(merlot2019.yield.pc),
#             mean.yield=mean(merlot2019.yield.pc),
#             var.quality=var(merlot2019.quality.pc),
#             mean.quality=mean(merlot2019.quality.pc),
#             var.yield=var(merlot2019.pruning.pc),
#             mean.yield=mean(merlot2019.pruning.pc))
# kable(mer19.tab, caption="\\label{mer19.summary.table} Summary statistics for outcome variables in the Chardonnay 2019 dataset.")
```



3. Visualization (side by side boxplots for each response variable - block)

```{r}
# ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.growth.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "growth") +
#   ylab("growth")+
#   facet_wrap(~block) 
# 
# ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.yield.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "yield") +
#   facet_wrap(~block) 
# 
# ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.quality.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "quality") +
#   facet_wrap(~block) 
# 
# ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.pruning.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "pruning") +
#   facet_wrap(~block) 
```

### merlot 2020
1. table of mean and variance under control and treatment for each response variable

```{r}
# mer20.tab<-merlot2020.pca %>% 
#   group_by(block, treatment) %>% 
#   summarise(var.growth=var(merlot2020.growth.pc),
#             mean.growth=mean(merlot2020.growth.pc),
#             var.yield=var(merlot2020.yield.pc),
#             mean.yield=mean(merlot2020.yield.pc),
#             var.quality=var(merlot2020.quality.pc),
#             mean.quality=mean(merlot2020.quality.pc))
# kable(mer20.tab, caption="\\label{char19.summary.table} Summary statistics for outcome variables in the Chardonnay 2019 dataset.")
```

2. Visualization (side by side boxplots for each response variable)



3. Visualization (side by side boxplots for each response variable - block)

```{r}
# ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.growth.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "growth") +
#   ylab("growth")+
#   facet_wrap(~block) 
# 
# ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.yield.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "yield") +
#   facet_wrap(~block) 
# 
# ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.quality.pc, fill=treatment)) +
#   scale_fill_manual(values=c("lightblue2", "seashell2"))+
#   geom_boxplot()+
#   labs(title = "quality") +
#   facet_wrap(~block) 
```

Based on the side-by-side box plots above, it seems that many outcome variables do not have equal variance, or the distribution is not quite normal. One limitation which can explain this is that our sample size is really small for each treatment in each block(5 or 6 data points). Hence, the plot cannot really tell much useful information about the data. 

Below, wilcoxon rank tests can be performed to test whether the distribution in control and treatment groups are the same. (that would be a lot of tests... I only tried out the test for number of clusters in Char2019 for five blocks.)

### randomization test
chardonnay 2019
```{r}
# for (i in unique(chardonnay2019$block)){
#   res=wilcox.test(chardonnay2019$X..of.clusters[chardonnay2019$block==i 
#                                                 & chardonnay2019$treatment=="heat"],
#                   chardonnay2019$X..of.clusters[chardonnay2019$block==i 
#                                                 & chardonnay2019$treatment=="control"],
#                   exact=FALSE)
#   print(res)
# }
```

QQ plot for number of clusters in chardonnary 2019 (for each block/treatment combo)

```{r, echo=FALSE}
# for (i in unique(chardonnay2019$block)){
#   qqnorm(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
#   qqline(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"], col = "red")
#   qqnorm(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"])
#   qqline(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"], col = "red")
# }
```

F test and randomization test for equal variance of number of cluster between treatments for each block in chardonnary 2019
```{r, echo=FALSE}
# for (i in unique(chardonnay2019$block)){
#   res = var.test(chardonnay2019$X..of.clusters[chardonnay2019$block==i 
#                                                & chardonnay2019$treatment=="heat"], 
#                  chardonnay2019$X..of.clusters[chardonnay2019$block==i 
#                                                & chardonnay2019$treatment=="control"])
#   print("F test")
#   print(res$p.value)
#   
#   # randomization test for equal variance
#   n = 2*length(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
#   n1 = length(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
#   totalComb <- combn(n, n1)
#   dim(totalComb)
#   
#   totalComb.complement <- matrix(nrow = dim(totalComb)[1], ncol = dim(totalComb)[2])
#   for (j in 1:dim(totalComb)[2]) {
#     totalComb.complement[,j] = (1:n)[-totalComb[,j]]
#   }
#   
#   # replace the indices by the actual value.
#   dat = chardonnay2019$X..of.clusters[chardonnay2019$block==i]
#   dat.mat <- matrix(dat[totalComb], ncol = choose(n, n1))
#   dat.mat.complement <- matrix(dat[totalComb.complement], ncol = choose(n, n1))
#   
#   # calculate the d_obs
#   d.obs <- abs(var(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"]) - var(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"]))
#   
#   # calculate all other ds
#   abs.diff.var <- rep(0, dim(totalComb)[2])
#   for (j in 1:dim(totalComb)[2]) {
#     abs.diff.var[j] = abs(var(dat.mat[,j]) - var(dat.mat.complement[,j]))
#   }
# 
#   c1 <- sum(abs.diff.var > d.obs)
#   c2 <- sum(abs.diff.var == d.obs)
#   p.val <- (c1 + 0.5*c2)/choose(n, n1)
#   print("rand test")
#   print(p.val)
# }
```

QQ plot for the growth PC in merlot 2020 (for each block/treatment combo)

```{r, echo=FALSE}
# for (i in unique(merlot2020.pca$block)){
#   qqnorm(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
#   qqline(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"], col = "red")
#   qqnorm(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"])
#   qqline(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"], col = "red")
# }
```

F test and randomization test for equal variance between treatments for each block in merlot 2020
```{r, echo=FALSE}
# for (i in unique(merlot2020.pca$block)){
#   res = var.test(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"], merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"])
#   print("F test")
#   print(res$p.value)
#   
#   # randomization test for equal variance
#   n = 2*length(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
#   n1 = length(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
#   totalComb <- combn(n, n1)
#   dim(totalComb)
#   
#   totalComb.complement <- matrix(nrow = dim(totalComb)[1], ncol = dim(totalComb)[2])
#   for (j in 1:dim(totalComb)[2]) {
#     totalComb.complement[,j] = (1:n)[-totalComb[,j]]
#   }
#   
#   # replace the indices by the actual value.
#   dat = merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i]
#   dat.mat <- matrix(dat[totalComb], ncol = choose(n, n1))
#   dat.mat.complement <- matrix(dat[totalComb.complement], ncol = choose(n, n1))
#   
#   # calculate the d_obs
#   d.obs <- abs(var(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"]) - var(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"]))
#   
#   # calculate all other ds
#   abs.diff.var <- rep(0, dim(totalComb)[2])
#   for (j in 1:dim(totalComb)[2]) {
#     abs.diff.var[j] = abs(var(dat.mat[,j]) - var(dat.mat.complement[,j]))
#   }
# 
#   c1 <- sum(abs.diff.var > d.obs)
#   c2 <- sum(abs.diff.var == d.obs)
#   p.val <- (c1 + 0.5*c2)/choose(n, n1)
#   print("rand test")
#   print(p.val)
# }
```

We see that the normality assumptions are slightly violated, and the equal variance assumptions are also violated even though we only compared variances between treatments within each block. Therefore we will use both a parametric and a non parametric test in the following analysis. (Should repeat the above for all other variables.)

# Univariate analysis
## Univariate boxplots

```{r char.univ, fig.cap="\\label{year.char.boxplot} Boxplots of the overall distributions of factors looked at for Chardonnay, divided by year. These plots give us an idea of if there are any glaring outliers."}

# # Let's check distributions of variables
# resp.char <- c("X..of.clusters", "yield..kg.", "av.cluster.weight..kg.")
# labels.char <- c("Number of clusters", "Yield (kg)", "Average cluster weight (kg)")
# par(mfrow=c(2,2), mar=c(1,2,2,1))
# for (i in 1:length(resp.char)) {
#   boxplot(chardonnay2019[,which(names(chardonnay2019)==resp.char[i])], 
#           chardonnay2020[,which(names(chardonnay2020)==resp.char[i])], cex.main=1, main=labels.char[i],
#           xlab="Year")
# }

```

```{r mer2019.univ}

# # Define the features we want to consider for merlot
# resp.mer <- unique(c(colnames(merlot2019)[-c(1:5, 7)], colnames(merlot2020)[-c(1:5, 7:8)]))
# 
# # Strictly univariate: check for outliers
# par(mfrow=c(4,4), mar=c(1,2,2,1))
# for (i in 1:length(resp.mer)) {
#   if (resp.mer[i] %in% c("pruning.weight", "Ravaz.index")) {
#   boxplot(merlot2019[,which(names(merlot2019)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
#   } else if (resp.mer[i] %in% c("fruitfulness", "brown.seed.color")) {
#   boxplot(merlot2020[,which(names(merlot2020)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
#   } else {
#   boxplot(merlot2019[,which(names(merlot2019)==resp.mer[i])], 
#           merlot2020[,which(names(merlot2020)==resp.mer[i])], cex.main=0.9, main=resp.mer[i],
#           xlab="Year")
#   }
# }

```




# Checking assumptions for statistical tests

We will be running ANOVAs on all outcome variables except Bloom and Veraison to determine whether the treatment influenced the outcome variables. ANOVA tests have two main assumptions:

1. Homoscedasticity: each combination of the treatment and blocking factors have equal variances.
2. Normality: the outcome variable is approximately normal for each combination of the treatment and blocking factors.
3. Independence: the samples tested are obtained independently.
4. Equal sample size: each combination of the treatment and blocking factors have equal sample sizes.

## Homoscedasticity
```{r homoscedas.merlot}
library(lawstat)
# Create lists of the variables we want to check for homoscedasticity and normality
resp.mer19 <- colnames(merlot2019)[-c(1:5, 7)]
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7,9)]

# Create some tables to save the results of our statistical tests in
homosc.table.mer19 <- array(data=NA, dim=c(length(resp.mer19), 2, 5))
dimnames(homosc.table.mer19)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.mer19)[[1]] <- resp.mer19

homosc.table.mer20 <- array(data=NA, dim=c(length(resp.mer20), 2, 5))
dimnames(homosc.table.mer20)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.mer20)[[1]] <- resp.mer20

# Compare variances for each unique treatment-block group
for (i in 1:length(resp.mer19)) {

  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- unlist(lapply(with(merlot2019,
                               bartlett.test(eval(parse(text=resp.mer19[i])) ~ paste(treatment, block)))$analyses,
                          FUN=function(x){x$p.value}))
  lev.p  <- unlist(lapply(with(merlot2019,
                        levene.test(eval(parse(text=resp.mer19[i])), paste(treatment, block)))$analyses,
                          FUN=function(x){x$p.value}))
  homosc.table.mer19[i,1,] <- bart.p
  homosc.table.mer19[i,2,] <- lev.p
}


# Check out how many of the tests came back with a significant result
uneq.var.mer19 <- apply(homosc.table.mer19, c(1,2), function(x){sum(x<0.05)})

# Boxplots of the first imputation dataset for the variables with potentially
# unequal variances
par(mfrow=c(sum(rowSums(uneq.var.mer19)>0),1))
lapply(rownames(uneq.var.mer19)[rowSums(uneq.var.mer19)>0], function(x){
  with(merlot2019,
       boxplot(cluster.weight ~ paste0(block, treatment))
       )[[1]]})
```

```{r fig.cap="Distributions of variables for which equal variance assumptions were violated for at least one of the subgroups being analyzed."}

for (i in 1:length(resp.mer20)) {
  
  # Run bartlett test on every variable for every
  # imputed datset
  bart.p <- unlist(lapply(with(merlot2020mice, 
                               bartlett.test(eval(parse(text=resp.mer20[i])) ~ paste(treatment, block)))$analyses, 
                          FUN=function(x){x$p.value}))
  
  # Run levene test on every variable for every imputed
  # dataset
  lev.p  <- unlist(lapply(with(merlot2020mice, 
                        levene.test(eval(parse(text=resp.mer20[i])), paste(treatment, block)))$analyses,
                          FUN=function(x){x$p.value}))  
  homosc.table.mer20[i,1,] <- bart.p
  homosc.table.mer20[i,2,] <- lev.p
}

# Check out how many of the tests came back with a significant result
uneq.var.mer20 <- apply(homosc.table.mer20, c(1,2), function(x){sum(x<0.05)})

# Boxplots of the first imputation dataset for the variables with potentially
# unequal variances
par(mfrow=c(sum(rowSums(uneq.var.mer20)>0),1), mar=c(3,3,3,3))
for (var in rownames(uneq.var.mer20)[rowSums(uneq.var.mer20)>0]) {
  
  # merlot2020[as.numeric(rownames(merlot2020mice$imp[var][[1]])),
  #            which(colnames(merlot2020) %in% c("block", "treatment"))]
  
  # Plot the non-imputed data
  boxplot(split(merlot2020[,which(colnames(merlot2020)==var)],
             paste0(merlot2020$block, merlot2020$treatment)),
          main=var)

}
resp.mer19 <- colnames(merlot2019)[-c(1:5, 7)]
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7:8)]

homosc.table.mer19 <- data.frame("Variable"=rep(NA, length(resp.mer)),
                                 "Bartlett p-value"=rep(NA, length(resp.mer)),
                                 "Levene p-value"=rep(NA, length(resp.mer)))

```


```{r homoscedas.chardonnay}

library(lawstat)
resp.char19 <- colnames(chardonnay2019)[-c(1:5)]
resp.char20 <- colnames(chardonnay2020)[-c(1:5)]

homosc.table.char19 <- array(data=NA, dim=c(length(resp.char19), 2))
dimnames(homosc.table.char19)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.char19)[[1]] <- resp.char19

homosc.table.char20 <- array(data=NA, dim=c(length(resp.char20), 2))
dimnames(homosc.table.char20)[[2]] <- c("Bartlett", "Levene")
dimnames(homosc.table.char20)[[1]] <- resp.char20

# Compare variance between treatment and block
for (i in 1:length(resp.char19)) {
  
  # the lapply function simply extracts the p-value from each outputted run of the MICE data
  bart.p <- with(chardonnay2019, 
                               bartlett.test(eval(parse(text=resp.char19[i])) ~ paste(treatment, block)))$p.value
  lev.p  <- with(chardonnay2019, 
                        levene.test(eval(parse(text=resp.char19[i])), paste(treatment, block)))$p.value
  homosc.table.char19[i,1] <- bart.p
  homosc.table.char19[i,2] <- lev.p
}
for (i in 1:length(resp.char20)) {
  bart.p <- with(chardonnay2020, 
                               bartlett.test(eval(parse(text=resp.char20[i])) ~ paste(treatment, block)))$p.value
  lev.p  <- with(chardonnay2020, 
                        levene.test(eval(parse(text=resp.char20[i])), paste(treatment, block)))$p.value
  homosc.table.char20[i,1] <- bart.p
  homosc.table.char20[i,2] <- lev.p
}

par(mar=c(4,4,3,3))
boxplot(chardonnay2019$X..of.clusters ~ chardonnay2019$treatment + chardonnay2019$block,
        xlab="Treatment + Block", ylab="Number of clusters")
```


## Normality

We used Shapiro-Wilkes tests to check the normality assumption of the ANOVA tests, checking each block-treatment combination for each of the tested variables. For any Shapiro-Wilkes tests that resulted in a potentially significant breach from normality, the Q-Q plots were plotted (Figures \ref{qq.mer19}, \ref{qq.mer20}, \ref{qq.char19}, \ref{qq.char20}).

Upon observations of the Q-Q plots, it looks like deviations are largely due to outliers. This may pose a problem in the accuracy of the ANOVA tests as ANOVA can be sensitive to outliers. 

```{r qq.mer19, fig.cap="\\label{qq.mer19} Q-Q plots for treatment-block groups in the Merlot 2019 data that indicated a potentially significant breach from normality. The number in the title for each plot indicates the block, followed by the treatment and the variable in question."}

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.mer19 <- array(NA, c(12, length(resp.mer19)))
colnames(norm.tests.mer19) <- resp.mer19
rownames(norm.tests.mer19) <- unique(paste(merlot2019$block, merlot2019$treatment))[order(unique(paste(merlot2019$block, merlot2019$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2019 dataset
for (i in 1:length(resp.mer19)) {
  shapiro.results <- with(merlot2019, {lapply(split(eval(parse(text=resp.mer19[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:12) {norm.tests.mer19[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.mer19<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.mer19)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.mer19)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(3,3), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(merlot2019[which(paste(merlot2019$block, merlot2019$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(merlot2019[which(paste(merlot2019$block, merlot2019$treatment)==non.norm[i,1]),non.norm[i,2]])
}

```

```{r qq.mer20, fig.cap="\\label{qq.mer20} Q-Q plots for treatment-block groups in the Merlot 2020 data that indicated a potentially significant breach from normality. The number in the title for each plot indicates the block, followed by the treatment and the variable in question. Imputed data points are plotted in red."}

# Run shapiro-wilkes tests on each of the variables
norm.tests.mer20 <- array(NA, c(12, length(resp.mer20), 5))
dimnames(norm.tests.mer20)[[2]] <- resp.mer20
dimnames(norm.tests.mer20)[[1]] <- unique(paste(merlot2020$block, merlot2020$treatment))

# Run the shapiro wilkes test on each of the outcome variables in the Merlot 2019 dataset
for (i in 1:length(resp.mer20)) {
  shapiro.results <- with(merlot2020mice, {lapply(split(eval(parse(text=resp.mer20[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (j in 1:5) {for (k in 1:12) {norm.tests.mer20[k,i,j] <- shapiro.results$analyses[[j]][[k]]$p.value}}}

# Get a table of when a p-value for the Shapiro-Wilkes tests
# was <0.05, indicating a potential divergence from normality
nonnorm.mer20 <- apply(norm.tests.mer20, c(1,2), function(x){sum(x<0.05)})
nonnorm.mer20.rowcol <- which(nonnorm.mer20>0, arr.ind=T)
nonnorm.mer20.rowcol[,2] <- colnames(nonnorm.mer20)[nonnorm.mer20.rowcol[,2]]
nonnorm.mer20.rowcol[,1] <- rownames(nonnorm.mer20)[as.numeric(nonnorm.mer20.rowcol[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(4,5), mar=c(3,3,3,3))
for (i in 1:dim(nonnorm.mer20.rowcol)[1]) {
  dat <- with(merlot2020mice, {
       dat <- eval(parse(text=nonnorm.mer20.rowcol[i,2]))
       dat[which(paste(block, treatment)==nonnorm.mer20.rowcol[i,1])]})$analyses
  
  # Get the Q-Q plot quantiles -- the x-axis of our Q-Q plot
  quantiles <- rep(c(-1.1797611, -0.4972006,  0, 0.4972006,  1.1797611), 5)
  
  # The y-values of our imputed datasets, ordered appropriately
  yvals <- unlist(lapply(dat, function(x){x[order(x)]}))
  
  # Define the color for the points: the 
  col <- is.na(merlot2020[which(paste(merlot2020$block, 
                                      merlot2020$treatment)==nonnorm.mer20.rowcol[i,1]), 
                          nonnorm.mer20.rowcol[i,2]])[order(dat[[1]])]
  
  # Plot our Q-Q plot
  plot(quantiles, yvals, col=rep(col+1, 5), 
       main=paste0(nonnorm.mer20.rowcol[i,1], "\n", nonnorm.mer20.rowcol[i,2]),
       pch=16)
}


```


```{r qq.char19, fig.cap="\\label{qq.char19} Q-Q plots for treatment-block groups in the Chardonnay 2019 data that indicated a potentially significant breach from normality. The number in the title for each plot indicates the block, followed by the treatment and the variable in question."}

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.char19 <- array(NA, c(10, length(resp.char19)))
colnames(norm.tests.char19) <- resp.char19
rownames(norm.tests.char19) <- unique(paste(chardonnay2019$block, chardonnay2019$treatment))[order(unique(paste(chardonnay2019$block, chardonnay2019$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the chardonnay 2019 dataset
for (i in 1:length(resp.char19)) {
  shapiro.results <- with(chardonnay2019, {lapply(split(eval(parse(text=resp.char19[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:10) {norm.tests.char19[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.char19<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.char19)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.char19)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(2,2), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(chardonnay2019[which(paste(chardonnay2019$block, chardonnay2019$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(chardonnay2019[which(paste(chardonnay2019$block, chardonnay2019$treatment)==non.norm[i,1]),non.norm[i,2]])
}

```

```{r qq.char20, fig.cap="\\label{qq.char19} Q-Q plots for treatment-block groups in the Chardonnay 2019 data that indicated a potentially significant breach from normality. The number in the title for each plot indicates the block, followed by the treatment and the variable in question."}

# Run shapiro-wilkes tests on each of the variables we will run ANOVAs on
norm.tests.char20 <- array(NA, c(10, length(resp.char20)))
colnames(norm.tests.char20) <- resp.char20
rownames(norm.tests.char20) <- unique(paste(chardonnay2020$block, chardonnay2020$treatment))[order(unique(paste(chardonnay2020$block, chardonnay2020$treatment)))]

# Run the shapiro wilkes test on each of the outcome variables in the chardonnay 2020 dataset
for (i in 1:length(resp.char20)) {
  shapiro.results <- with(chardonnay2020, {lapply(split(eval(parse(text=resp.char20[i])), 
                                                        paste0(block, treatment)), 
                                                  shapiro.test)})
  # Save the shapiro wilkes tests for each of the populations (unique combination of block & treatment)
  # in one large array
  for (k in 1:10) {norm.tests.char20[k,i] <- shapiro.results[[k]]$p.value}
}

# Find the row and column names of the potentially non-normal data
non.norm <- which(norm.tests.char20<0.05, arr.ind=T)
non.norm[,2] <- colnames(norm.tests.char20)[non.norm[,2]]
non.norm[,1] <- rownames(norm.tests.char20)[as.numeric(non.norm[,1])]
# Plot the Q-Q plots of the potentially non-normal groups
par(mfrow=c(2,1), mar=c(3,3,3,3))
for (i in 1:dim(non.norm)[1]) {
  qqnorm(chardonnay2020[which(paste(chardonnay2020$block, chardonnay2020$treatment)==non.norm[i,1]),non.norm[i,2]],
         main=paste("Q-Q plot:", non.norm[i,1], non.norm[i,2]))
  qqline(chardonnay2020[which(paste(chardonnay2020$block, chardonnay2020$treatment)==non.norm[i,1]),non.norm[i,2]])
}
```

# Statistical analyses

## Cox PH models for censored data

As previously discussed, Bloom and Veraison were both censored data for the Merlot datasets. For some of the plants, 100% bloom or veraison had already occurred, so the event (50% bloom or veraison) was left-censored. For other plants, the berries or flowers had not yet grown, indicating that the event was right-censored (the event had not yet been observed). In this analysis, we discern the two groups by whether or not the number of clusters reported is greater than or equal to zero. If there were no clusters, then we assume right-censoring; otherwise, we assume left-censoring.

Both bloom and veraison were measured three times (at times T1, T2, and T3), and the approximate event date (50% veraison or 50% bloom) was determined using a linear regression. There are two types of missing data: 

(1) The event did not occur because no berries or flowers grew. This is known as right-censored data. In this case, the event happened in the interval (T3,Inf)
(2) The event already occurred prior to the first observation. This is known as left-censored data. In this case, the event happened sometime in the interval (-Inf, T1].

For Bloom, T1= June 25 (= 25); T2=June 29 (= 29), and T3= July 1 (= 31)
For Veraison, T1=August 31 (= 31), T2=September 2 (= 33), and T3=September 5 (36).

Additionally, for veraison, until we hear from the client, we can impute the lower bound of the interval for left-censored data as the 50% bloom date, since we know berry ripening would happen sometime after flowers blooming.

After treating the data as interval data, we can then construct Cox proportional hazards models to fit the data. We used tools in an R package called icenReg, which uses bootstrapping for inference on the regression parameters to perform hypothesis testing.

```{r surv.2020}

bloom.t1 <- 25
bloom.t3 <- 31
ver.t1 <- 31
ver.t3 <- 36

# First define our dataset of start and end times for our event intervals
icen.mer20 <- with(merlot2020, {
  
  # If the data isn't censored (non-NA bloom), let the start and end be equal to each other
  icen.mer20 <- data.frame("bloom.start"=bloom, "bloom.end"=bloom,
                           "verais.start"=veraison, "verais.end"=veraison,
                           "trt"=treatment, "block"=block)

  # If the data is right-censored (cluster.number==0; event happened after
  # the study period of interest), then let the "start" be the imputed value
  # and set the ending value to Inf
  icen.mer20$bloom.start[is.na(bloom) & cluster.number==0] <- bloom.t3
  icen.mer20$bloom.end[is.na(bloom) & cluster.number==0] <- Inf
  
  icen.mer20$verais.start[is.na(veraison) & cluster.number==0] <- ver.t3
  icen.mer20$verais.end[is.na(veraison) & cluster.number==0] <- Inf
  
  # If the data is left-censored (event happened before we started recording Veraison)
  # (cluster.number>0), then let the "end" be the imputed value and
  # set the starting value to -Inf
  # For veraison, we can set the starting value to the max of -Inf and the 50% bloom date
  left.bloom <- is.na(bloom) & cluster.number>0
  icen.mer20$bloom.start[left.bloom] <- -Inf
  icen.mer20$bloom.end[left.bloom] <- bloom.t1
  
  left.ver <- is.na(veraison) & cluster.number>0
  icen.mer20$verais.start[left.ver] <- max(bloom[left.ver]-61, -Inf, na.rm=T)
  icen.mer20$verais.end[left.ver] <- ver.t1
  return(icen.mer20)
  })


library(icenReg)
# Build a model for the bloom data
coxph.bloom20 <- ic_sp(cbind(bloom.start,bloom.end) ~ trt + as.factor(block), 
               data=icen.mer20, model='ph', bs_samples=100)

# Build a model for the veraison data
coxph.ver20 <- ic_sp(cbind(verais.start,verais.end) ~ trt + as.factor(block), 
               data=icen.mer20, model='ph', bs_samples=100)


```

```{r surv.2019}

# First define our dataset of start and end times for our event intervals
icen.mer19 <- with(merlot2019, {
  
  # If the data isn't censored (non-NA bloom), let the start and end be equal to each other
  icen.mer19 <- data.frame("verais.start"=veraison, "verais.end"=veraison,
                           "trt"=treatment, "block"=block)

  # If the data is right-censored (cluster.number==0; event happened after
  # the study period of interest), then let the "start" be the T3 value
  # and set the ending value to Inf
  icen.mer19$verais.start[is.na(merlot2019$veraison) & cluster.number==0] <- ver.t1
  icen.mer19$verais.end[is.na(merlot2019$veraison) & cluster.number==0] <- Inf
  
  
  # If the data is left-censored (event happened before we started recording Veraison)
  # (cluster.number>0), then let the "end" be T3 and
  # set the starting value to -Inf
  left.ver <- is.na(merlot2019$veraison) & cluster.number>0
  icen.mer19$verais.start[left.ver] <- -Inf
  icen.mer19$verais.end[left.ver] <- ver.t3
  
  return(icen.mer19)
  })

# Build a model for the veraison data
coxph.ver19 <- ic_sp(cbind(verais.start,verais.end) ~ trt + as.factor(block), 
                  data=icen.mer19, model='ph', bs_samples=100)


```

Results indicate that neither the treatment nor the block effects influenced Veraison in either 2019 or 2020. Bloom was influenced by block effect but not by the treatment.

### Visual  analysis: censored data

```{r fig.cap="\\label{plot.ver} Probability of 50% Veraison happening x days into July for the Merlot 2019 and Merlot 2020 vineyard."}

colorsch <- c("darksalmon", "red", "darkred", "cornflowerblue", "darkcyan", "darkblue")
newdata <- data.frame(trt=c(rep("heat", 3), rep("control", 3)), "block"=as.character(1:6))
rownames(newdata) <- paste(newdata$trt, newdata$block)

par(mfrow=c(1,2))
plot(coxph.ver19, newdata, col=colorsch, lgdLocation="bottomleft", main="2019 Veraison")
plot(coxph.ver20, newdata, col=colorsch, lgdLocation="bottomleft", main="2020 Veraison")


```

```{r fig.cap="\\label{plot.ver} Probability of 50% Bloom happening x days into July for the Merlot 2020 vineyard."}

par(mfrow=c(1,1))
plot(coxph.bloom20, newdata, col=colorsch, lgdLocation="bottomleft", main="Bloom")


```

Censored data cannot be as adequately assessed visually using boxplots. A more appropriate method is to construct nonparametric maximum likelihood estimators. The resulting plots are shown in Figures \ref{np.ver} and \ref{np.bloom}. 


## Aligned rank transform ANOVA (nonparametric test for two-way layout) and ANOVA test


### Chardonnay 2019 number of clusters
```{r, echo=FALSE}
### Aligned rank transform ANOVA

dat = chardonnay2019
model = art(X..of.clusters ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA 
summary(aov(X..of.clusters ~ treatment + block + treatment:block, data = dat))
```

### Chardonnay 2019 yield

```{r, echo=FALSE}
### Aligned rank transform ANOVA
library(ARTool)
dat = chardonnay2019
model = art(yield..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(yield..kg. ~ treatment + block + treatment:block, data = dat))
```

### Chardonnay 2019 average cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2019
model = art(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat))
```

### Chardonnay 2020 number of clusters
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(X..of.clusters ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(X..of.clusters ~ treatment + block + treatment:block, data = dat))
```

block factor was found significant to the number of clusters in both tests.

### Chardonnay 2020 yield
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(yield..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(yield..kg. ~ treatment + block + treatment:block, data = dat))
```

Block factor was found significant to yield in both tests.

### Chardonnay 2020 average cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2019 SPAD
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(SPAD ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(SPAD ~ treatment + block + treatment:block, data = dat))
```

Again, block was found significant to the SPAD of grape in both test.

### Merlot 2019 cluster number
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(cluster.number ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(cluster.number ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2019 yield
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(yield ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(yield ~ treatment + block + treatment:block, data = dat))
```

Blocking is significant.

### Merlot 2019 cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(cluster.weight ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(cluster.weight ~ treatment + block + treatment:block, data = dat))
```

Blocking is significant, interaction is significant in ART but not in ANOVA (unreliable result?).

### Merlot 2019 berries cluster
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(berries.cluster ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berries.cluster ~ treatment + block + treatment:block, data = dat))
```

Blocking and interaction are significant. Treatment is on the boundary.

### Merlot 2019 berry weight
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(berry.weight ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.weight ~ treatment + block + treatment:block, data = dat))
```

Blocking and interaction are significant.

### Merlot 2019 berry TA
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(berry.TA ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.TA ~ treatment + block + treatment:block, data = dat))
```

Blocking is significant.

### Merlot 2019 berry pH
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(berry.pH ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.pH ~ treatment + block + treatment:block, data = dat))
```

All are significant except for treatment in ANOVA (unreliable?)

### Merlot 2019 berry Brix
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(berry.Brix ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.Brix ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2019 pruning weight
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(pruning.weight ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(pruning.weight ~ treatment + block + treatment:block, data = dat))
```

Blocking and interaction are significant.

### Merlot 2019 Ravaz index
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019
model = art(Ravaz.index ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(Ravaz.index ~ treatment + block + treatment:block, data = dat))
```

Interaction is significant.

### Merlot 2020 SPAD
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(SPAD ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)
print(res$`Pr(>F)`)

### ANOVA
summary(aov(SPAD ~ treatment + block + treatment:block, data = dat))
```

Block was found significant to the SPAD of grape in both test, and treatment is on the boundary.

### Merlot 2020 cluster number
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(cluster.number ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(cluster.number ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 yield
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(yield ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(yield ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(cluster.weight ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(cluster.weight ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 berries cluster
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(berries.cluster ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berries.cluster ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 berry weight
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(berry.weight ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.weight ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 berry TA
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(berry.TA ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.TA ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 berry pH
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(berry.pH ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.pH ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 berry Brix
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(berry.Brix ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(berry.Brix ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 fruitfulness
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(fruitfulness ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(fruitfulness ~ treatment + block + treatment:block, data = dat))
```

### Merlot 2020 brown seed color

```{r, echo=FALSE}
library(ARTool)
dat = merlot2020
model = art(brown.seed.color ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(brown.seed.color ~ treatment + block + treatment:block, data = dat))
```

Blocking is significant.

Only few treatment effects were found significant (all in 2019). Although some of the interaction effects are. Maybe heating only helps under certain geographical conditions? 

Another thing to check is the actual estimate of the treatment/blocking/interaction effects. We can also construct SEs of each of these effects. 

Also, we may perform **multiple comparison** to see exactly which level of block differs.

Can also combine data from both years and do repeated measures ANOVA?


## Summary of ANOVA and ART

```{r make.pval.tables}


# Define the variables I want to look at
resp.mer19 <- colnames(merlot2019)[-c(1:5, 7)]
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7,9)]
resp.char19 <- colnames(chardonnay2019)[-c(1:5)]
resp.char20 <- colnames(chardonnay2020)[-c(1:5)]
library(ARTool)

# Define a function that computes an ANOVA and ART for each outcome variable in a given dataset
# output is first the ART and secondly the ANOVA results
run.anova.art <- function(dat, response.vars) {
  art.mer20 <- vector("list", length(response.vars))
  anova.mer20 <- vector("list", length(response.vars))
  names(anova.mer20) <- response.vars
  names(art.mer20) <- response.vars
  
  # Now let's run the tests!
  for (i in 1:length(response.vars)) {
    
    # First we define the ART model we want to use. Then we run an analysis of variance
    art.mer20[[i]] = anova(art(eval(parse(text=response.vars[i])) ~ treatment + block + 
                                       treatment:block,
                               data=dat), type = 1)
    # Then we can run an ANOVA by using the lm() function to define our model
    anova.mer20[[i]] = anova(lm(eval(parse(text=response.vars[i])) ~ treatment + block + treatment:block,
                               data=dat))
  }
  
  # Concatenate all of the results
  mer20.test.outputs <- list(art.mer20, anova.mer20)
  return(mer20.test.outputs)
}

mer19.test.outputs <- run.anova.art(merlot2019, resp.mer19)
mer20.test.outputs <- run.anova.art(complete(merlot2020mice, 1), resp.mer20)
char19.test.outputs <- run.anova.art(chardonnay2019, resp.char19)
char20.test.outputs <- run.anova.art(chardonnay2020, resp.char20)

# For each data set for the ANOVAs and ARTs run, get a data frame indicating significance of the variables
generate.p.tables <- function(x){
  
  # First, for each test, extract just the coefficients and their significances
  ww <- lapply(x, function(t){as.data.frame(t)})
  
  # Now for each table, add in variables indicating the variable we are looking at
  # in the test, as well as the covariate that the row is talking about
  ww <- lapply(1:length(ww), 
                      function(t,xx=ww){cbind(xx[[t]][1:3,], 
                                        data.frame("Var"=rep(names(xx)[t],3),
                                                   "Covar"=rownames(xx[[t]])[1:3]))})
  # Bind all of the results for the tests together into one large data frame
  ww <- do.call(rbind.data.frame, ww)

  # Create a table that indicates p-values
  ww.ptab <- dcast(ww, Var~Covar, value.var="Pr(>F)")
  # Round to three decimal places to clean up the table
  ww.ptab[,c(2:4)] <- round(ww.ptab[,c(2:4)], 3)
  return(ww.ptab)
}

mer19.test.ptab <-lapply(mer19.test.outputs, generate.p.tables)
mer20.test.ptab <-lapply(mer20.test.outputs, generate.p.tables)
char19.test.ptab <-lapply(char19.test.outputs, generate.p.tables)
char20.test.ptab <-lapply(char20.test.outputs, generate.p.tables)



```

```{r print.pval.tables}

# Now create nicely formatted tables for the results.

kable(mer19.test.ptab[[1]], caption="\\label{ptab.mer19.art} Individual ART models were constructed for each of the outcome variables analyzed in the Merlot 2019 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(mer19.test.ptab[[2]], caption="\\label{ptab.mer19.anova} Individual ANOVA models were constructed for each of the outcome variables analyzed in the Merlot 2019 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(mer20.test.ptab[[1]], caption="\\label{ptab.mer20.art} Individual ART models were constructed for each of the outcome variables analyzed in the Merlot 2020 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(mer20.test.ptab[[2]], caption="\\label{ptab.mer20.anova} Individual ANOVA models were constructed for each of the outcome variables analyzed in the Merlot 2020 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(char19.test.ptab[[1]], caption="\\label{ptab.char19.art} Individual ART models were constructed for each of the outcome variables analyzed in the Chardonnay 2019 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(char19.test.ptab[[2]], caption="\\label{ptab.char19.anova} Individual ANOVA models were constructed for each of the outcome variables analyzed in the Chardonnay 2020 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(char20.test.ptab[[1]], caption="\\label{ptab.char20.art} Individual ART models were constructed for each of the outcome variables analyzed in the Chardonnay 2019 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")
kable(char20.test.ptab[[2]], caption="\\label{ptab.char20.anova} Individual ANOVA models were constructed for each of the outcome variables analyzed in the Chardonnay 2020 dataset. Reported here are the p-values indicating the significance of the block, treatment, and interaction effects for each of the outcome variables measured.")


```


## Repeated-measures ANOVA

```{r}

# First, let's combine the merlot2019 and merlot2020 datasets
merlot2019$year <- 2019
merlot2020mice$year <- 2020

names(merlot.bothyr)[[1]] <- "Key"

# Do the same for Chardonnay
chardonnay2019$year <- 2019
chardonnay2020$year <- 2020
chardonnay.bothyr <- rbind.fill(chardonnay2019, chardonnay2020)
```

```{r}

# Repeated-measures ANOVA. 
merlot.variables <- c("SPAD", "cluster.number", "yield", "cluster.weight",
                      "berries.cluster", "berry.weight")
merlot.imputed.vars <- c("berry.TA", "berry.pH", "berry.Brix")

for (var in merlot.variables) {
  # Repeated-measures ANOVA
  rep.aov <- aov(eval(deparse(text=var)) ~ block*treatment + 
                   year*treatment + Error(Key), 
            data=merlot.bothyr)
}

spad.art <- art(SPAD ~ block*treatment + year +
                (1 | Key), 
            data=merlot.bothyr)


```



## MANOVA

```{r chardonnay}

summary(manova(cbind(X..of.clusters, yield..kg., av.cluster.weight..kg.) ~ as.factor(treatment) * as.factor(block), data=chardonnay2020))

summary(manova(cbind(X..of.clusters, yield..kg., av.cluster.weight..kg.) ~ as.factor(treatment) * as.factor(block), data=chardonnay2019))

```

```{r manova.merlot2019}

# Yield-related measures
summary(manova(cbind(cluster.number, yield, cluster.weight, berries.cluster, berry.weight) ~ as.factor(treatment) * as.factor(block), data=merlot2019))

# Growth-related measures
summary(manova(cbind(SPAD, pruning.weight, Ravaz.index) ~ as.factor(treatment) * as.factor(block), data=merlot2019))

# Quality-related measures
summary(manova(cbind(berry.TA, berry.pH, berry.Brix) ~ as.factor(treatment)*as.factor(block), data=merlot2019))

```

```{r manova.merlot2020}

# Yield-related measures
summary(manova(cbind(cluster.number, yield, cluster.weight, berries.cluster, berry.weight) ~ as.factor(treatment) * as.factor(block), data=complete(merlot2020mice, 1)))

# Growth-related measures
summary(manova(cbind(SPAD, pruning.weight, Ravaz.index) ~ as.factor(treatment) * as.factor(block), data=complete(merlot2020mice, 1)))

# Quality-related measures
summary(manova(cbind(berry.TA, berry.pH, berry.Brix) ~ as.factor(treatment)*as.factor(block), data=complete(merlot2020mice, 1)))

```

MANOVA works best when the response variables are somewhat correlated but do not exhibit strong multicollinearity (which would be if they were over 90% correlated). The chardonnay 2019 and 2020 datasets indicated that they may be appropriate fits for MANOVA.

Merlot datasets had separt

