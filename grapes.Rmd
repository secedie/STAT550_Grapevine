---
title: "Grapevine"
author: "Naitong Chen, Shirley Cui, Shannon Edie"
output:
  pdf_document: default
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(corrplot)
library(survival)
library(knitr)
library(lawstat) # for the levene test
```

# Problem overview

Agro-thermal heat-treatment technology in grapevines has been shown to increase yield, decrease the use of agro-chemicals used to fight pests, enhance wine quality and improve profits, but this technology has not been tested in the Okanagan Valley or Canada. Heat treatment is applied by driving a tractor through the vineyard rows that blows extreme heat into the canopy. During the growing seasons of 2019 and 2020, heat treatment was applied to a Merlot and a Chardonnay vineyard in the Okanagan valley six times during the growing season with application ten days apart from each other. Treatments were: (1) heat, and (2) control (no heat).

# Data description

A full description of the recorded variables in the Chardonnay and Merlot studies can be seen in Figure \ref{var.descr.table}. The blocking structure, sample sizes, and a brief overview of missing data are explained below.

```{r read.data.in, include=FALSE}
merlot2020 = read.csv("TanjaVoegel_Merlot_2020_data.csv")
merlot2019 = read.csv("TanjaVoegel_Merlot_2019_data.csv")
chardonnay2019 = read.csv("TanjaVoegel_Chardonnay_2019_data.csv")
chardonnay2020 = read.csv("TanjaVoegel_Chardonnay_2020_data.csv")

# removing extra columns
merlot2020 = merlot2020[-(61:65),]
merlot2020 = merlot2020[,-(19:20)]
merlot2019 = merlot2019[-(61:65),]
merlot2019 = merlot2019[,-18]

# Make sure the merlot column names are consistent
colnames(merlot2020)[colnames(merlot2020)=="spad"] = "SPAD"

# encode row, treatment, block, and subsample as factor
chardonnay2019$row = as.factor(chardonnay2019$row)
chardonnay2019$treatment = as.factor(chardonnay2019$treatment)
chardonnay2019$block = as.factor(chardonnay2019$block)
chardonnay2019$subsample = as.factor(chardonnay2019$subsample)

chardonnay2020$row = as.factor(chardonnay2020$row)
chardonnay2020$treatment = as.factor(chardonnay2020$treatment)
chardonnay2020$block = as.factor(chardonnay2020$block)
chardonnay2020$subsample = as.factor(chardonnay2020$subsample)

merlot2019$row = as.factor(merlot2019$row)
merlot2019$treatment = as.factor(merlot2019$treatment)
merlot2019$block = as.factor(merlot2019$block)
merlot2019$subsample = as.factor(merlot2019$subsample)

merlot2020$row = as.factor(merlot2020$row)
merlot2020$treatment = as.factor(merlot2020$treatment)
merlot2020$block = as.factor(merlot2020$block)
merlot2020$subsample = as.factor(merlot2020$subsample)

```


```{r var.descr.table, echo=FALSE}

var.descr <- read.csv("Variable_descriptions.csv")
kable(var.descr, caption="\\label{var.descr.table} Variable descriptions.")

```

There are 40 samples in each of the Chardonnay 2019 and Chardonnay 2020 datasets. The 40 samples consist of 8 samples from each of the 5 blocks. Among the 8 samples within each block, 4 samples of each treatment are included.

Both Chardonnay datasets contain 3 measurements of each sample with no missing data.

There are 60 samples in each of the Merlot 2019 and Merlot 2020 datasets. The 60 samples consist of 10 samples from each of the 6 blocks. Among the 10 samples within each block, 5 samples of each treatment are included.

In the Merlot 2019 data set, there are missing values from the measurement of veraison. In the Merlot 2020 data set, there are missing vales from the measurements of veraison, bloom, yield, cluster weight, berries/cluster, berry weight, berry Brix, berry TA, berry pH, and brown seed color.

# Handling missing data

As mentioned above, missing data was unique to the Merlot datasets.

## Veraison

We know from the client that the veraison column indicates the number days into August in each respective year when 50% of the berries on a given vine had changed to red. The missing entries are a result of the vines reaching 50% veraison on the first day of measurement. They are missing not at random (MNAR) as whether this value is missing for each vine is dependent on this particular value. More specifically, if any of the missing values were recorded, it must be negative.

While imputation seems like a reasonable approach, since we know these values must be negative, we can take the maximum between each imputed value and zero to produce complete data sets?

Percentage of missing for the veraison measure of merlot2019 and merlot2020 are shown in Table \ref{missing.percent}.

```{r missing.percent, echo=FALSE}
kable(data.frame("Missing 2019"=paste0(round(mean(is.na(merlot2019$veraison)), 3)*100, "%"), 
                 "Missing 2020"=paste0(round(mean(is.na(merlot2020$veraison)), 3)*100), "%"),
      caption="\\label{missing.percent} Percentage of Veraison data that is missing in the 2019 and 2020 Merlot datasets.")
```

## Bloom

Similar to veraison, the bloom column includes values that indicate the number of days into June in each respective year when 50% of the flowers on a given vine had started to bloom. The missing entries are a result of the vines reaching 50% bloom on the first day of measurement. They are also missing not at random (MNAR). 

Again, we can consider taking the maximum between each imputed value and zero to produce complete data sets.

`r paste0(round(mean(is.na(merlot2020$bloom)), 3)*100, "%")` of the bloom data in the Merlot 2020 dataset is missing.

## Yield related measures

For all columns that contain missing values (yield, cluster weight, berries/cluster, berry weight), the reason for missing is that the vine had no yield. Even though these missing values depend on the measures of cluster number of their corresponding vines being zero, these yield related values are missing precisely because there are no yield. This is then also a case of missing not at random (MNAR). 

Assigning these missing entries the value of zero seems plausible.

Percentage of missing for the yield related measures of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$yield))
```

## Berry related measures

Similarly, for all columns that contain missing values (berry Brix, berry TA, berry pH, brown seed color), the reason for missing is that the vine had no yield. These values are missing simply because there were no grapes produced to have these measurements recorded. Depending on the relationship between berry quality and yield, this is either a case of missing at random (MAR, in the absence of an association between berry quality and yield) or missing completely at random (MCAR, in the presence of an association between berry quality and yield). 

Due to the structure of the study, particularly the existence of blocking and replication, imputation seems to be the most reasonable approach to fill in the missing values.

Percentage of missing for the berry related measures of merlot2020 is shown below.

```{r, echo=FALSE}
mean(is.na(merlot2020$berry.Brix))
```

## Question

In the merlot2020 data set, most of the vines that had no entries for bloom or veraison (implying earlier ripening) also had no yield. This is against my intuition. If anything, as observed in the other three data sets, early ripening may be associated with higher yield? What was the weather event that caused some of the vines to have no yield?

# Constructing complete data sets

We construct complete data sets using the approaches described above. Once these complete data sets are constructed, analysis can be done separately on each of the imputed data sets. Although we need to look into the necessity and methods to aggregate these results. We should also look into the order or columns to impute, as well as whether all responses should be used to predict the missing values.

For now, I have imputed with and without the yield related measures. We may consider more variants such as using only responses that are highly correlated.

Linear regerssions are used for imputation. There are a lot more available options specified on page 76 of https://cran.r-project.org/web/packages/mice/mice.pdf.

Note that the the columns of key, row and subsample are excluded from all imputations below.

## merlot2019

The imputed values of veraison for merlot2019 from the first imputed data set are shown below. Note they are all above zero, they will all be filled in with zero before the analysis.

```{r, include=FALSE}
# load mice
library(mice)

# imputing veraison for merlot2019 using all responses (exclusing key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2019)^2), ncol(merlot2019), ncol(merlot2019))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2019mice = mice(data = merlot2019, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

```{r, echo=FALSE}
# checking imputed values
merlot2019full_1 = complete(merlot2019mice, 1)
print(merlot2019full_1$veraison[is.na(merlot2019$veraison)])
```

## merlot2020

```{r, include=FALSE}
# filling in zero for yield related entries
merlot2020$yield[is.na(merlot2020$yield)] = 0
merlot2020$cluster.weight[is.na(merlot2020$cluster.weight)] = 0
merlot2020$berries.cluster[is.na(merlot2020$berries.cluster)] = 0
merlot2020$berry.weight[is.na(merlot2020$berry.weight)] = 0

# imputation for merlot2020 using all responses (excluding key, row and subsample)
predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")

# imputation for merlot2020 not using yield related columns (also excluding key, row and subsample)
predMatrix[,c(11,14)] = 0
merlot2020miceNoYield = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

The first set of imputed values for merlot2020 using all responses are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020mice, 1)

print("veraison")
print(merlot2020full_1$veraison[is.na(merlot2020$veraison)])

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

The first set of imputed values for merlot2020 not using yield related measures are shown below.

```{r, echo=FALSE}
# checking imputed values
merlot2020full_1 = complete(merlot2020miceNoYield, 1)

print("veraison")
print(merlot2020full_1$veraison[is.na(merlot2020$veraison)])

print("berry Brix")
print(merlot2020full_1$berry.Brix[is.na(merlot2020$berry.Brix)])

print("berry pH")
print(merlot2020full_1$berry.pH[is.na(merlot2020$berry.pH)])

print("berry TA")
print(merlot2020full_1$berry.TA[is.na(merlot2020$berry.TA)])

print("brown seed color")
print(merlot2020full_1$brown.seed.color[is.na(merlot2020$brown.seed.color)])
```

Again the veraison values are all above zero, and so zero values will assigned before conducting the analysis.

We therefore won't need to do imputation on veraison altogether, and so can proceed for now using the following three sets of data (merlot2019, merlot2020 imputed with filled-in zeros, merlot2020 imputed without filled-in zeros).

```{r, include=FALSE}
merlot2019$veraison[is.na(merlot2019$veraison)] = 0

merlot2020$veraison[which(is.na(merlot2020$veraison) & merlot2020$cluster.number > 0)] = 0

predMatrix = matrix(rep(1,ncol(merlot2020)^2), ncol(merlot2020), ncol(merlot2020))
diag(predMatrix) = 0
predMatrix[,1] = 0
predMatrix[,4] = 0
predMatrix[,5] = 0
merlot2020mice = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")

# predMatrix[,c(11,14)] = 0
# predMatrix[,9] = 0
# merlot2020miceNoZero = mice(data = merlot2020, predictorMatrix = predMatrix, seed = 1, method = "norm.predict")
```

Check out the imputed data sets in the code blocks!

```{r, include=FALSE}
merlot2019 # this is now complete
complete(merlot2020mice, 1) # first (out of 5) imputed data set for merlot2020 using all responses including the filled-in zeros
# complete(merlot2020miceNoZero, 1) # first (out of 5) imputed data set for merlot2020 without the filled-in zeros
```

## data preprocessing - PCA
Basically, we have reduced the dimentions of the dataset down to four/three dimensions for merlot 2013/2014 using PCA.
```{r, include=FALSE}
# carry forward with the following data sets (response variables only)
char2019.resp <- select(chardonnay2019,(-1:-5))
char2020.resp <- select(chardonnay2020, (-1:-5))
merlot2019.resp <- select(merlot2019,(-1:-5))
merlot2020.resp <- select(complete(merlot2020mice, 1),(-1:-5))
```

```{r, include=FALSE}
# extracting features
# 2019
merlot2019.growth <- select(merlot2019.resp,(1:2))
res <- prcomp(merlot2019.growth, center = TRUE, scale = TRUE)
merlot2019.growth.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9577232

merlot2019.yield <- select(merlot2019.resp,(3:7))
res <- prcomp(merlot2019.yield, center = TRUE, scale = TRUE)
merlot2019.yield.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9741755

merlot2019.quality <- select(merlot2019.resp,(8:10))
res <- prcomp(merlot2019.quality, center = TRUE, scale = TRUE)
merlot2019.quality.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.78826

merlot2019.pruning <- select(merlot2019.resp,(11:12))
res <- prcomp(merlot2019.pruning, center = TRUE, scale = TRUE)
merlot2019.pruning.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9996358

# 2020
merlot2020.growth <- select(merlot2020.resp,c(1:4,13))
res <- prcomp(merlot2020.growth, center = TRUE, scale = TRUE)
merlot2020.growth.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.7180542

merlot2020.yield <- select(merlot2020.resp,(5:9))
res <- prcomp(merlot2020.yield, center = TRUE, scale = TRUE)
merlot2020.yield.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.9821489

merlot2020.quality <- select(merlot2020.resp,(10:12))
res <- prcomp(merlot2020.quality, center = TRUE, scale = TRUE)
merlot2020.quality.pc <- res$x[,1]
var_explained = (res$sdev^2/(sum(res$sdev^2)))[1] # 0.8134009
```


```{r, include=FALSE}
# putting together extracted datasets
merlot2019.pca = cbind(merlot2019[-61:-65, 1:5], merlot2019.growth.pc, merlot2019.yield.pc,
                            merlot2019.quality.pc, merlot2019.pruning.pc)
merlot2019.pca = data.frame(merlot2019.pca)

merlot2020.pca = cbind(merlot2020[-61:-65, 1:5], merlot2020.growth.pc, merlot2020.yield.pc,
                            merlot2020.quality.pc)
merlot2020.pca = data.frame(merlot2020.pca)
```

```{r, include=FALSE}
# Now proceed with analysis using the following data sets
chardonnay2019
chardonnay2020
merlot2019.pca
merlot2020.pca
```

# Check for correlations
### chardonnay 2019
```{r}
chardonnay2019 %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
From the output of correlation function, there seem no correlations between response variables.

### chardonnay 2020
```{r}
chardonnay2020 %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
Yield is found to be positively correlated with number of clusters.

### merlot 2019
```{r}
merlot2019.pca %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
### merlot 2020
```{r}
merlot2020.pca %>% 
  select(-1:-5) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, addCoef.col="white", number.cex=0.7)
```
From the correlation matrix plots, there seem to be no obvious correlations among the response variables in these four datasets. We are good to continue with normality and equal variance assumptions check.

## Check for assumption of ANOVA test: normality and equal variance
### Chardonnay 2019 
1. table of mean and variance under control and treatment for each response variable
```{r}
chardonnay2019 %>% 
  group_by(block, treatment) %>% 
  summarise(var.num_of_cluster=var(X..of.clusters),
            mean.num_of_cluster=mean(X..of.clusters),
            var.yield=var(yield..kg.),
            mean.yield=mean(yield..kg.),
            var.cluster_weight=var(av.cluster.weight..kg.),
            mean.cluster_weight=mean(av.cluster.weight..kg.))
```

2. Visualization (side by side boxplots for each response variable)
```{r}
## check assumptions of number of clusters
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = X..of.clusters, fill=treatment))+
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "number of clusters") +
  ylab("number of clusters")+
  facet_wrap(~block)

## check assumptions of yield
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = yield..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  ylab("yield")+
  facet_wrap(~block) 

## check assumptions for average cluster weight
chardonnay2019 %>% 
  ggplot(aes(x=treatment, y = av.cluster.weight..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "average cluster weight") +
  ylab("average cluster weight")+
  facet_wrap(~block) 
```
### Chardonnay 2020
1. table of mean and variance under control and treatment for each response variable
```{r}
chardonnay2020 %>% 
  group_by(block, treatment) %>% 
  summarise(var.num_of_cluster=var(X..of.clusters),
            mean.num_of_cluster=mean(X..of.clusters),
            var.yield=var(yield..kg.),
            mean.yield=mean(yield..kg.),
            var.cluster_weight=var(av.cluster.weight..kg.),
            mean.cluster_weight=mean(av.cluster.weight..kg.))
```
2. Visualization (side by side boxplots for each response variable)
```{r}
## check assumptions of number of clusters
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = X..of.clusters, fill=treatment))+
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "number of clusters") +
  ylab("number of clusters")+
  facet_wrap(~block)

## check assumptions of yield
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = yield..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  ylab("yield")+
  facet_wrap(~block) 

## check assumptions for average cluster weight
chardonnay2020 %>% 
  ggplot(aes(x=treatment, y = av.cluster.weight..kg., fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "average cluster weight") +
  ylab("average cluster weight")+
  facet_wrap(~block) 
```
### merlot 2019
1. table of mean and variance under control and treatment for each response variable
```{r}
merlot2019.pca %>% 
  group_by(block, treatment) %>% 
  summarise(var.growth=var(merlot2019.growth.pc),
            mean.growth=mean(merlot2019.growth.pc),
            var.yield=var(merlot2019.yield.pc),
            mean.yield=mean(merlot2019.yield.pc),
            var.quality=var(merlot2019.quality.pc),
            mean.quality=mean(merlot2019.quality.pc),
            var.yield=var(merlot2019.pruning.pc),
            mean.yield=mean(merlot2019.pruning.pc))

```

2. Visualization (side by side boxplots for each response variable)
```{r}
ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.growth.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "growth") +
  ylab("growth")+
  facet_wrap(~block) 

ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.yield.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  facet_wrap(~block) 

ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.quality.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "quality") +
  facet_wrap(~block) 

ggplot(merlot2019.pca, aes(x=treatment, y = merlot2019.pruning.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "pruning") +
  facet_wrap(~block) 
```

### merlot 2020
1. table of mean and variance under control and treatment for each response variable
```{r}
merlot2020.pca %>% 
  group_by(block, treatment) %>% 
  summarise(var.growth=var(merlot2020.growth.pc),
            mean.growth=mean(merlot2020.growth.pc),
            var.yield=var(merlot2020.yield.pc),
            mean.yield=mean(merlot2020.yield.pc),
            var.quality=var(merlot2020.quality.pc),
            mean.quality=mean(merlot2020.quality.pc))
```

2. Visualization (side by side boxplots for each response variable)
```{r}
ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.growth.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "growth") +
  ylab("growth")+
  facet_wrap(~block) 

ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.yield.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "yield") +
  facet_wrap(~block) 

ggplot(merlot2020.pca, aes(x=treatment, y = merlot2020.quality.pc, fill=treatment)) +
  scale_fill_manual(values=c("lightblue2", "seashell2"))+
  geom_boxplot()+
  labs(title = "quality") +
  facet_wrap(~block) 
```

Based on the side-by-side box plots above, it seems that many outcome variables do not have equal variance, or the distribution is not quite normal. One limitation which can explain this is that our sample size is really small for each treatment in each block(5 or 6 data points). Hence, the plot cannot really tell much useful information about the data. 

Below, wilcoxon rank tests can be performed to test whether the distribution in control and treatment groups are the same. (that would be a lot of tests... I only tried out the test for number of clusters in Char2019 for five blocks.)
### randomization test
chardonnay 2019
```{r}
for (i in unique(chardonnay2019$block)){
  res=wilcox.test(chardonnay2019$X..of.clusters[chardonnay2019$block==i 
                                                & chardonnay2019$treatment=="heat"],
                  chardonnay2019$X..of.clusters[chardonnay2019$block==i 
                                                & chardonnay2019$treatment=="control"],
                  exact=FALSE)
  print(res)
}
```

QQ plot for number of clusters in chardonnary 2019 (for each block/treatment combo)

```{r, echo=FALSE}
for (i in unique(chardonnay2019$block)){
  qqnorm(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
  qqline(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"], col = "red")
  qqnorm(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"])
  qqline(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"], col = "red")
}
```

F test and randomization test for equal variance of number of cluster between treatments for each block in chardonnary 2019
```{r, echo=FALSE}
for (i in unique(chardonnay2019$block)){
  res = var.test(chardonnay2019$X..of.clusters[chardonnay2019$block==i 
                                               & chardonnay2019$treatment=="heat"], 
                 chardonnay2019$X..of.clusters[chardonnay2019$block==i 
                                               & chardonnay2019$treatment=="control"])
  print("F test")
  print(res$p.value)
  
  # randomization test for equal variance
  n = 2*length(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
  n1 = length(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"])
  totalComb <- combn(n, n1)
  dim(totalComb)
  
  totalComb.complement <- matrix(nrow = dim(totalComb)[1], ncol = dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    totalComb.complement[,j] = (1:n)[-totalComb[,j]]
  }
  
  # replace the indices by the actual value.
  dat = chardonnay2019$X..of.clusters[chardonnay2019$block==i]
  dat.mat <- matrix(dat[totalComb], ncol = choose(n, n1))
  dat.mat.complement <- matrix(dat[totalComb.complement], ncol = choose(n, n1))
  
  # calculate the d_obs
  d.obs <- abs(var(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="heat"]) - var(chardonnay2019$X..of.clusters[chardonnay2019$block==i & chardonnay2019$treatment=="control"]))
  
  # calculate all other ds
  abs.diff.var <- rep(0, dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    abs.diff.var[j] = abs(var(dat.mat[,j]) - var(dat.mat.complement[,j]))
  }

  c1 <- sum(abs.diff.var > d.obs)
  c2 <- sum(abs.diff.var == d.obs)
  p.val <- (c1 + 0.5*c2)/choose(n, n1)
  print("rand test")
  print(p.val)
}
```

QQ plot for the growth PC in merlot 2020 (for each block/treatment combo)

```{r, echo=FALSE}
for (i in unique(merlot2020.pca$block)){
  qqnorm(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
  qqline(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"], col = "red")
  qqnorm(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"])
  qqline(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"], col = "red")
}
```

F test and randomization test for equal variance between treatments for each block in merlot 2020
```{r, echo=FALSE}
for (i in unique(merlot2020.pca$block)){
  res = var.test(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"], merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"])
  print("F test")
  print(res$p.value)
  
  # randomization test for equal variance
  n = 2*length(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
  n1 = length(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"])
  totalComb <- combn(n, n1)
  dim(totalComb)
  
  totalComb.complement <- matrix(nrow = dim(totalComb)[1], ncol = dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    totalComb.complement[,j] = (1:n)[-totalComb[,j]]
  }
  
  # replace the indices by the actual value.
  dat = merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i]
  dat.mat <- matrix(dat[totalComb], ncol = choose(n, n1))
  dat.mat.complement <- matrix(dat[totalComb.complement], ncol = choose(n, n1))
  
  # calculate the d_obs
  d.obs <- abs(var(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="heat"]) - var(merlot2020.pca$merlot2020.growth.pc[merlot2020.pca$block==i & merlot2020.pca$treatment=="control"]))
  
  # calculate all other ds
  abs.diff.var <- rep(0, dim(totalComb)[2])
  for (j in 1:dim(totalComb)[2]) {
    abs.diff.var[j] = abs(var(dat.mat[,j]) - var(dat.mat.complement[,j]))
  }

  c1 <- sum(abs.diff.var > d.obs)
  c2 <- sum(abs.diff.var == d.obs)
  p.val <- (c1 + 0.5*c2)/choose(n, n1)
  print("rand test")
  print(p.val)
}
```

We see that the normality assumptions are slightly violated, and the equal variance assumptions are also violated even though we only compared variances between treatments within each block. Therefore we will use both a parametric and a non parametric test in the following analysis. (Should repeat the above for all other variables.)

# Univariate analysis
## Univariate boxplots

```{r char.univ, fig.cap="\\label{year.char.boxplot} Boxplots of the overall distributions of factors looked at for Chardonnay, divided by year. These plots give us an idea of if there are any glaring outliers."}

# Let's check distributions of variables
resp.char <- c("X..of.clusters", "yield..kg.", "av.cluster.weight..kg.")
labels.char <- c("Number of clusters", "Yield (kg)", "Average cluster weight (kg)")
par(mfrow=c(2,2), mar=c(1,2,2,1))
for (i in 1:length(resp.char)) {
  boxplot(chardonnay2019[,which(names(chardonnay2019)==resp.char[i])], 
          chardonnay2020[,which(names(chardonnay2020)==resp.char[i])], cex.main=1, main=labels.char[i],
          xlab="Year")
}

```

```{r mer2019.univ}

# Define the features we want to consider for merlot
resp.mer <- unique(c(colnames(merlot2019)[-c(1:5, 7)], colnames(merlot2020)[-c(1:5, 7:8)]))

# Strictly univariate: check for outliers
par(mfrow=c(4,4), mar=c(1,2,2,1))
for (i in 1:length(resp.mer)) {
  if (resp.mer[i] %in% c("pruning.weight", "Ravaz.index")) {
  boxplot(merlot2019[,which(names(merlot2019)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
  } else if (resp.mer[i] %in% c("fruitfulness", "brown.seed.color")) {
  boxplot(merlot2020[,which(names(merlot2020)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
  } else {
  boxplot(merlot2019[,which(names(merlot2019)==resp.mer[i])], 
          merlot2020[,which(names(merlot2020)==resp.mer[i])], cex.main=0.9, main=resp.mer[i],
          xlab="Year")
  }
}

```


# Assumptions

We will be running ANOVAs on all outcome variables except Bloom and Veraison to determine whether the treatment influenced the outcome variables. ANOVA tests have two main assumptions:

1. Homoscedasticity: each combination of the treatment and blocking factors have equal variances.
2. Normality: the outcome variable is approximately normal for each combination of the treatment and blocking factors.
3. Independence: the samples tested are obtained independently.
4. Equal sample size: each combination of the treatment and blocking factors have equal sample sizes.

## Homoscedasticity

```{r homoscedas.merlot}

library(lawstat)
resp.mer19 <- colnames(merlot2019)[-c(1:5, 7)]
resp.mer20 <- colnames(merlot2020)[-c(1:5, 7:8)]

homosc.table.mer19 <- data.frame("Variable"=rep(NA, length(resp.mer)),
                                 "Bartlett p-value"=rep(NA, length(resp.mer)),
                                 "Levene p-value"=rep(NA, length(resp.mer)))

# Compare variance between treatment
par(mfrow=c(4,4), mar=c(1,2,2,1))
for (i in 1:length(resp.mer)) {
  var <- merlot2019[,which(names(merlot2019)==resp.mer[i])]
  boxplot(var[!is.na(var)] ~ merlot2019$treatment[!is.na(var)], 
          cex.main=0.9, main=resp.mer[i])
  p <- bartlett.test(var[!is.na(var)] ~ merlot2019$treatment[!is.na(var)])$p.value
  p.2 <- levene.test(var[!is.na(var)], 
                     as.factor(merlot2019$treatment[!is.na(var)]))$p.value
  print(paste(resp.mer[i], round(p, 3), round(p.2, 3)))
}
# Compare variance between blocks
par(mfrow=c(4,4), mar=c(1,2,2,1))
for (i in 1:length(resp.mer)) {
  var <- mer[,which(names(mer)==resp.mer[i])]
  boxplot(var[!is.na(var)] ~ mer$block[!is.na(var)], 
          cex.main=0.9, main=resp.mer[i])
  p <- bartlett.test(var[!is.na(var)] ~ mer$block[!is.na(var)])$p.value
  p.2 <- levene.test(var[!is.na(var)], 
                     as.factor(mer$block[!is.na(var)]))$p.value
  print(paste(resp.mer[i], round(p, 3), round(p.2, 3)))
}

```

```{r homoscedas.char}

# Compare variance between treatment
par(mfrow=c(2,2), mar=c(1,2,2,1))
for (i in 1:length(resp.char)) {
  boxplot(char[,which(names(char)==resp.char[i])] ~ char$treatment, cex.main=0.9, main=resp.char[i])
  p <- bartlett.test(char[,which(names(char)==resp.char[i])] ~ char$treatment)$p.value
  print(paste(resp.char[i], p))
}
# Compare variance between blocks
par(mfrow=c(2,2), mar=c(1,2,2,1))
for (i in 1:length(resp.char)) {
  boxplot(char[,which(names(char)==resp.char[i])] ~ char$block, cex.main=0.9, main=resp.char[i])
  p <- bartlett.test(char[,which(names(char)==resp.char[i])] ~ char$block)$p.value
  print(paste(resp.char[i], p))
}
```

## Normality

```{r qq.mer}

# Check normality
par(mfrow=c(4,4), mar=c(1,2,2,1))
for (i in 1:length(resp.mer)) {
  qqnorm(mer[mer$treatment=="heat",which(names(mer)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
  qqline(mer[mer$treatment=="heat",which(names(mer)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
}
for (i in 1:length(resp.mer)) {
  qqnorm(mer[mer$treatment=="control",which(names(mer)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
  qqline(mer[mer$treatment=="control",which(names(mer)==resp.mer[i])], cex.main=0.9, main=resp.mer[i])
}

```

# Statistical analyses

# Aligned rank transform ANOVA (nonparametric test for two-way layout) and ANOVA test

## Chardonnay 2019 number of clusters
```{r, echo=FALSE}
### Aligned rank transform ANOVA
library(ARTool)
dat = chardonnay2019
model = art(X..of.clusters ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA 
summary(aov(X..of.clusters ~ treatment + block + treatment:block, data = dat))
```

## Chardonnay 2019 yield
```{r, echo=FALSE}
### Aligned rank transform ANOVA
library(ARTool)
dat = chardonnay2019
model = art(yield..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(yield..kg. ~ treatment + block + treatment:block, data = dat))
```

## Chardonnay 2019 average cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2019
model = art(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat))
```

## Chardonnay 2020 number of clusters
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(X..of.clusters ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(X..of.clusters ~ treatment + block + treatment:block, data = dat))
```

block factor was found significant to the number of clusters in both tests.

## Chardonnay 2020 yield
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(yield..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(yield..kg. ~ treatment + block + treatment:block, data = dat))
```

Block factor was found significant to yield in both tests.

## Chardonnay 2020 average cluster weight
```{r, echo=FALSE}
library(ARTool)
dat = chardonnay2020
model = art(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(av.cluster.weight..kg. ~ treatment + block + treatment:block, data = dat))
```

## Merlot 2019 growth PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.growth.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2019.growth.pc ~ treatment + block + treatment:block, data = dat))
```

Again, block was found significant to the growth of grape (specifically what?) in both test. Treatment was also found significant in ANOVA, but ANOVA assumption does not hold, the result may not be reliable.

## Merlot 2019 yield PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.yield.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2019.yield.pc ~ treatment + block + treatment:block, data = dat))
```

Block was again found significantly influential to yield

## Merlot 2019 quality PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.quality.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2019.quality.pc ~ treatment + block + treatment:block, data = dat))
```

## Merlot 2019 pruning PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2019.pca
model = art(merlot2019.pruning.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2019.pruning.pc ~ treatment + block + treatment:block, data = dat))
```

Interaction was found significant in pruning (pruning weight, Ravaz index)

## Merlot 2020 growth PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020.pca
model = art(merlot2020.growth.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2020.growth.pc ~ treatment + block + treatment:block, data = dat))
```

treatment and interaction were found significantly related to the growth. Maybe a particular geographical area combined with the heating technique effect are beneficial for the growth of grapes. We may also conduct **multiple comparison**.

## Merlot 2020 yield PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020.pca
model = art(merlot2020.yield.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2020.yield.pc ~ treatment + block + treatment:block, data = dat))
```

## Merlot 2020 quality PC
```{r, echo=FALSE}
library(ARTool)
dat = merlot2020.pca
model = art(merlot2020.quality.pc ~ treatment + block + treatment:block, data = dat)
res = anova(model, type = 1)
print(res)

### ANOVA
summary(aov(merlot2020.quality.pc ~ treatment + block + treatment:block, data = dat))
```

Only one treatment effect was found significant (growth in merlot 2020). Although some of the interaction effects are. Maybe heating only helps under certain geographical conditions? 

Another thing to check is the actual estimate of the treatment/blocking/interaction effects. We can also construct SEs of each of these effects. 

Also, we may perform **multiple comparison** to see exactly which level of block differs.

Can also combine data from both years and do repeated measures ANOVA?

